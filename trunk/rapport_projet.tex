\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}

\lstset{language=C, basicstyle=\scriptsize, numbers=left, numberstyle=\footnotesize, numbersep=7pt}

\title{Rapport projet de programmation 2016}
\author{Groupe A1\_2\\Gautier DELACOUR\\Anthony DELASALLE\\Alexis PICHON\\Amélie RISI}


\begin{document}
\maketitle
\tableofcontents

\chapter{Le projet}
Ce projet a été réalisé dans le cadre d'une UE. Le but était de créer un jeu Rush Hour ou similaire à celui-ci à l'aide du langage de programmation C. 
\section{Première version}
Le projet consistait en l'implémentation de plusieurs modules permettant de jouer à un jeu de type Rush Hour dont le principe est simple: on dispose d'un tableau de jeu sur lequel sont présentes plusieurs pièces de forme rectangulaire. L'une de ces pièces est la pièce maîtresse du jeu. Il faut donc faire sortir celle-ci en déplaçant toutes les pièces qui la gène. Cependant, chaque pièce ne peut se déplacer uniquement dans un seul type de direction, soit horizontalement, soit verticalement.
Dans cette première version, il nous était demandé de fournir seulement une interface pour un terminal.

\section{Deuxième version}
Par la suite, des contraintes se sont ajoutées au développement du projet. En effet, on nous a spécifié que notre code devait désormais être valable aussi pour un jeu de type Ane Rouge. Sur ce type de jeu, les pièces peuvent aussi être de forme carrée et n'ont pas forcément de restrictions sur le type de mouvement. De plus, à la différence d'un jeu Rush Hour où la pièce maîtresse doit rejoindre le côté droit du plateau pour gagner, la pièce maîtresse doit ici rejoindre le bas du plateau de jeu pour gagner.
Une fois encore le jeu doit être jouable sur une version terminal mais une interface graphique de base peut maintenant être implémentée, mais elle reste optionnelle.

\section{Le solveur}
Pour terminer un solveur est attendu, permettant bien évidemment de résoudre tout niveau de Rush Hour ou de l'Ane Rouge en fonction des paramètres entrés. Le but est de trouver un algorithme pour résoudre tout jeu de la manière la plus rapide et optimisée possible.


\chapter{Notre conception du projet}
\setcounter{section}{0}
Lors de notre conception du projet, nous avons eu pour but d'essayer de respecter les réglementations au niveau, par exemple des headers initiaux que l'on avait pas le droit de modifiés et de test unitaires  à créer. De plus, nous avions décidés de créer une interface terminal qui soit protéger au niveau des erreurs de saisies d'argument par exemple. Néanmoins, suite à certain problème, nous n'avons pas pu délivré notre travail de la V1 dans les temps impartit avec tous les objectifs remplit. De même, lors de la réalisation de la deuxième version du projet, nous avons aussi eu des problèmes pour créer des exécutables pour l'âne rouge et le rush hour qui soit fonctionnels. Pour finir, notre solveur est complément néant suite à un manque d'organisation dans le groupe.

Pour ce projet, nous avons décidé d'utiliser un dépôt svn et cmake pour compiler notre projet.
\section{Architecture du projet}
Notre projet s'articule autour de la V1 et de la V2. Nous avons séparé les deux versions suite à la modification des headers \textit{piece} et \textit{game} lors du changement des spécifications.

Voici la structure de la V1 et de la V2 à une exception tous ce qui est lié à l'affichage terminal est dans exec:

\begin{itemize}
\item[Build :]Dossier qui permet de créer tous les fichiers liés à cmake et la compilation.
\item[Include :]Dossier pour tous les headers.
\item[Lib :]Dossier où toutes les libs sont après leur création
\item[Src :]Dossier où se trouvent tous nos .c. Ce dossier est organisé comme suit :
  \begin{itemize}
  \item[Game :]Ce dossier décrit toutes foctionnnalité liée à un jeu de Rush Hour, c'est-à-dire les pièces et le game ainsi que les tests unitaires de ces modules.
  \item[Rush Hour :]Ce dossier décrit le rush hour, c'est-à-dire il n'y a qu'un main dans le fichiers .c qui crée un jeu de rush hour. 
  \item[Exec :]Ce dossier décrit l'excution d'un jeu.
  \item[Io\_interface :]Ce dossier décrit l'interface sur le terminal.
  \end{itemize}
\end{itemize}

\section{Les modules}
\subsection*{Module piece.c}
Ce module contient la structure d'une pièce ainsi que toutes les fonctions relatives à ces dernières. C'est ce module qui va nous permettre de créer les pièces de notre jeu, de les modifier (déplacer) ou de les supprimer.
\subsection*{Module game.c}
Ce module contient la structure d'un jeu ainsi que toutes les fonctions qui s'y appliquent. Il nous permet de créer le plateau de jeu, d'y placer les pièces dedans et de les déplacer non plus dans le simple cadre d'une pièce comme pour le module précédant mais dans un envirronement de jeu avec d'autres pièces autour et des limites imposées par les dimensions du plateau.
%Les modules piece et game sont brièvement expliqués, n'hésitais pas ajouter des infos qui vous semblent importantes
%Pour les modules suivant je ne pense pas les maîtriser suffisemment pour en parler, je vous laisse donc le faire



\chapter{Les tests}
\setcounter{section}{0}
%pour Gautier tu sera content comme ça
%decrit tes tests parle de ceux de la V1 et de la V2 ainsi que les derniers de la list chaine seulement car tu as seulement ci ceux la
%explique pourquoi maintenant tu mets des phrases avant chaque action pour dire ce que tu fais à chaque moment
%en gros parle de l'evolution de ton écriture de code
%tu peux sur la fin parler de la tab de hash mais pas trop vu que tu ne l'a pas commit tu en reparlera après



\chapter{Le solveur}
\setcounter{section}{0}
\section{Première approche}
Dans un premier temps, notre approche de la conception du solveur s'est orientée vers l'encadrement du problème.
Il s'agit de trouver une méthode de résolution d'un problème dans l'espace et le temps, le jeu étant en deux dimensions et se déroulant en étapes successives.
Pour ce faire, il a été indispensable de s'interroger sur les structures de données susceptibles de convenir pour le stockage des tours d'une partie.
Les contraintes du jeu imposaient de s'intéresser aux structures de données ordonnées, telles que les listes chaînées ou les arbres.
Toutefois, il ne faut pas négliger de prendre en considération que pour un tour donné dans une partie, il existe plusieurs actions possibles.
Cela élimine la possibilité d'utiliser des listes chaînées.
L'autre information importante dégagée est relative à la recherche d'un plus court chemin : si un tour donné de la partie permet plusieurs choix, il est également vrai que différents choix de mouvements peuvent mener à une même configuration des pièces.
Parce que ces chemins peuvent être de taille différente, la structure de données choisie est celle d'une table de hachage à adressage chaîné.
L'utilisation d'une table de hachage permet de trier les configurations des pièces indépendament d'un avancement dans le temps.
La structure des clés de hachage correspondant à la position des pièces à une étape donnée :
\begin{itemize}
\item un premier chiffre pour la position en X de la pièce 
\item un second pour la position en Y 
\end{itemize}
Ces coordonnées sont celles de l'angle bas-gauche de la pièce en question
Ce choix d'organisation permet un stockage des tours indépendant de nombre de tours écoulés, qui sont stockés dans chaque chaque cellule de la table.
Les cellules sont organisées de la façon suivante :
\begin{itemize}
\item clé de hachage
\item tableau de pointeurs pour les tours suivants possibles
\end{itemize}

\section{Deuxième approche}
%la je vais écrire cette partie



\chapter{Analyse mémoire}
\setcounter{section}{0}
\section{Valgrind}
%faire une analyse fuite mémoire sur tout notre projet et mettre en annexe capture d'écran
%y a t-il des problèmes de free et tout ça

\section{Couverture de code}
%pareil pour ça



\chapter{Organisation}
\setcounter{section}{0}
\section{Répartition des tâches}
\subsubsection*{Première partie du projet pour la V1}
La première étape du projet nous demandait d'implémenter les modules \textbf{piece.c} et \textbf{game.c} sur lesquels seront effectués des test unitaires. Ces modules contiennent les fonctions qui permettent au jeu de fonctionner, un dernier module gérant l'affichage du jeu sur terminal. Il y avait 4 grands axe à développer et nous nous sommes donc répartis les taches de la sorte:
\begin{description}
\item [Gautier:] implémentation du test unitaire sur game
\item [Anthony:] implémentation du module piece
\item [Alexis:] implémentation du module d'affichage du jeu
\item [Amélie:] implémentation du module game
\end{description}
Par la suite Alexis s'est occupé de structurer notre projet pour un repérage plus facile des fichiers et de faire les Makelists permettant d'obtenir un exécutable.
\subsubsection*{Suite de projet pour la V2}
L'évolution du projet vers la v2 nous demandait de faire en sorte que notre code, qui devait permettre lors de la V1 de jouer à Rush Hour, puisse aussi nous permettre de jouer à l'Ane Rouge. Il a donc fallut revoir les modules \textbf{piece.c} et \textbf{game.c} ainsi que le test unitaire sur \textbf{game.c}. De plus le test unitaire sur \textbf{piece.c} de la V1 n'étant plus en vigueur il a aussi fallut implémenter les test unitaire de ce module.
\begin{description}
\item [Mise à niveau de module game] Amélie
\item [Mise à niveau du module piece] Anthony
\item [Implémentation des tests unitaires sur game et piece] Equitablement réparti entre Gautier et Anthony
\item [Implémentation du module d'affichage de l'Ane Rouge] Alexis
\end{description}

\subsection{Module piece}
\subsubsection*{Structure d'une pièce}
Chaque pièce du jeu est défine par les coordonnées (x,y) de son angle bas-gauche, sa hauteur et sa largeur sur le plateau ainsi que par sa faculté à se déplacer de manère verticale et/ou horizontale.
On a donc une structure à six champs qui sont:
\begin{itemize}
\item \textbf{x} un entier correspondant à la coordonnée de l'angle bas-gauche de la pièce sur l'axe des abscisses
\item \textbf{y} un entier correspondant à la coordonnée de l'angle bas-gauche de la pièce sur l'axe des ordonnées
\item \textbf{width} un entier correspondant à la largeur de la pièce
\item \textbf{height} un entier correspondant à la hauteur de la pièce
\item \textbf{move\_x} un booléen indiquant si la pièce peut etre déplacée horizontalement
\item \textbf{move\_y} un booléen indiquant si la pièce peut etre déplacée verticalement
\end{itemize} 
\subsubsection*{La fonction \textit{new\_piece\_rh(int x, int y, bool small, bool horizontal)}}
Cette fonction nous permet de créer une pièce de jeu initialisée aux coordonnées (x,y) entrées en paramètres. Les deux booléens \textit{small} et \textit{horizontal} vont nous permettre à eux deux de déterminer les valeurs des champs \textit{width}, \textit{height}, \textit{move\_x} et \textit{move\_y}. En effet cette fonction n'est valable que dans le cas d'un jeu Rush Hour où les pièces ne peuvent effectuer qu'un seul type de movement et dont la taille (largeur ou hauteur en fonction de son inclinaison) est de 2 ou de 3, le second champs étant à 1. Par exemple une pièce initialisé avec un \textit{small} à \textit{false} et un \textit{horizontal} à \textit{true} aura une largeur de 3 et une hauteur de 2. De plus étant horizontale elle aura \textit{move\_x} à \textit{true} et \textit{move\_y} à \textit{false}.
\begin{lstlisting}
piece new_piece_rh(int x, int y, bool small, bool horizontal)
{
  piece p = malloc(sizeof(*p));
  if (p==NULL)
  {
    fprintf(stderr, "Allocation probleme");
    exit(EXIT_FAILURE);
  }
  p->x = x;
  p->y = y;
  if (horizontal)
  {
    p->width = 3;
    p->height = 1;
    p->move_x = true;
    p->move_y = false;
    if (small)
      p->width -= 1;
  }
  else
  {
    p->width = 1;
    p->height = 3;
    p->move_x = false;
    p->move_y = true;
    if (small)
      p->height -= 1;
  }
  return p;
}
\end{lstlisting}
On se contente ici d'allouer dynamiquement un espace mémoire à cette nouvelle pièce avant de lui attribuer les valeurs souhaitées.
\subsubsection*{La fonction \textit{new\_piece(int x, int y, int width, int height, bool move\_x, bool move\_y)}}
Le principe est le même que la fonction précédante hormis le fait qu'on initialise ici nous-même les valeurs de \textit{width}, \textit{height}, \textit{move\_x} et \textit{move\_y} afin de convenir aux possibilités offertes par un jeu de même type que l'Ane Rouge. Dans ce jeu les pièces n'ont pas de restrictions de dimension en dehors de celles imposées par le plateau de jeu et peuvent se déplacer à la fois en abscisse et en ordonnée.
\subsubsection*{La fonction \textit{delete\_piece(piece p)}}
Simple fonction permettant de supprimer une pièce créée. On se contente de vérifier si la pièce passée en paramètre n'est pas \textit{null} avant de faire un \textit{free} de cette pièce.
\subsubsection*{La fonction \textit{copy\_piece(cpiece src, piece dst)}}
Cette fonction prend deux pièce en paramètre et vérifie si elle ne sont pas \textit{null}. Si le test passe on copie les valeurs de la pièce \textit{src} dans la pièce \textit{dst}. Dans le cas contraire un message d'erreur est affiché pour avertir qu'au moins une des pièces entrées en paramètre ne convient pas.
\subsubsection*{La fonction \textit{move\_piece(piece p, dir d, int distance)}}
Cette fonction nous permet de décaler les coordonnées (x,y) de la pièce entrée en paramètre de \textit{distance} dans la direction \textit{d} choisi. Si on veut bouger la pièce verticalement on modifie la coordonée \textit{y} sinon la coordonnée \textit{x}. La \textit{distance} est additionnée ou soustraite en fonction de la direction. Bien évidemment on vérifie avant toute modification que les champs de la pièce sont en accord avec le déplacement souhaité.
\subsubsection*{La fonction \textit{intersect(cpiece p1, cpiece p2)}}
Dans cette fonction on test si deux pièces entrées en paramètres se croisent, c'est-à-dire si elles occupent une même place sur la plateau, auquel cas elle retourne \textit{true}. Afin de savoir si il y a effectivement intersection ou pas on commence par tester si les deux pièces ont les mêmes coordonnées (x,y): si oui la fonction retourne \textit{true} dès maintenant. Sinon on poursuit en comparant les angles des pièces. Si l'angle de la bas-gauche de la première pièce et situé avant l'angle haut-droit de la seconde pièce et si l'angle haut-droit de la première pièce est aussi situé après l'angle bas-gauche de la seconde pièce alors il y a intersection.
\begin{lstlisting}
bool intersect (cpiece p1, cpiece p2)
{
  if (get_x(p1) == get_x(p2) && get_y(p1) == get_y(p2)) 
    return true;
  int x1=get_x(p1);
  int x2=get_x(p2);
  int y1=get_y(p1);
  int y2=get_y(p2);
  if ((x1 < x2+get_width(p2)) && (x1+get_width(p1) > x2))
    if ((y1 < y2+get_height(p2)) && (y1+get_height(p1) > y2))
      return true;
  return false;
}
\end{lstlisting}

\subsection{Module game}
\subsubsection{Structure d'un jeu}
Le plateau de jeu est définie par ses dimensions hauteur*largeur et l'ensemble de pièces qui le compose. Sa structure est donc composée des champs \textit{board} un tableau 2D représentant le plateau de jeu, les entiers \textit{width} et \textit{height} correspondants respectivement aux dimensions en largeur et en hauteur du plateau ainsi que du champs \textit{piece} qui va contenir toutes pièces qui seront présentes sur le jeu. On dispose également du champs \textit{nb\_piece} pour connaître le nombre exact de pièces présentes en jeu et d'un dernier champs \textit{nb\_move} pour savoir combien de mouvement de pièces ont été réalisé depuis le début du jeu. Ce dernier champs est inclus dans la structure car il est propre à chaque jeu.
\subsubsection{La fonction \textit{new\_game (int width, int height, int nb\_pieces, piece *pieces)}}
Pour créer un nouveau plateau de jeu on initialise un tableau 2D par allocation dynamique de dimension \textit{width} et \textit{height}. On copie ensuite chaque pièces du tableau de pièces passé en paramètre dans le champs \textit{piece} après s'être assuré qu'elle ne soit pas en dehors du plateau. Une fois ces deux étapes effectuées on place les pièces sur le plateau en attribuant à chaque case du plateau le numéro de la pièce qu'il l'occupe ou -1 si aucune pièce n'est présente.
\begin{lstlisting}
game new_game (int width, int height, int nb_pieces, piece *pieces)
{
  if(pieces==NULL || nb_pieces<=0 || pieces[0]==NULL || width<=0 || height<=0)
      return NULL;

  game new_g = malloc (sizeof (*new_g));
  if (new_g==NULL)
      fprintf(stderr,"Problem in the allocation of newGame!!!\n");

  new_g->board = malloc (sizeof(*(new_g->board))*height);
  if (new_g->board==NULL)
      fprintf(stderr, "Problem in the allocation of newGame's board (height)\n");
  for (int j= 0; j<height; ++j)
  {
      new_g->board[j] = (int *) malloc (sizeof(*(new_g->board[j]))*width);
    if (new_g->board[j]==NULL)
      fprintf(stderr, "Probleme in the allocation of newGame's board (width)\n");
  }

  new_g->width = width;
  new_g->height = height;
  new_g->nb_move = 0;
  new_g->nb_piece = 0;

  new_g->piece = malloc (nb_pieces * sizeof(*pieces));
  if (new_g->piece==NULL)
      fprintf(stderr,"Problem in allocation of piece in structure\n");
     
  for (int i=0; i<nb_pieces; ++i)
  {
      if (!is_in_grid(new_g, pieces[i]))
	fprintf(stderr, "Piece %d out of board\n", i);

      new_g->piece[i] = new_piece(get_x(pieces[i]), get_y(pieces[i]), get_width(pieces[i]), get_height(pieces[i]), can_move_x(pieces[i]), can_move_y(pieces[i]));
      new_g->nb_piece += 1;
  }

  positionning(new_g, (cpiece*)new_g->piece);

  if (new_g->nb_piece != nb_pieces)
  {
      delete_game(new_g); // free of all we allocated before
      new_g = NULL;
  }
  return new_g;
}
\end{lstlisting}
\subsubsection{La fonction \textit{game new\_game\_hr (int nb\_piece, piece *piece)}}
Dans ce cas, on créer un jeu dont les conditions sont propres à Rush Hour.
Il s'agit d'un simple appel à la fonction \textit{new\_game} avec les dimensions d'un plateau de Rush Hour.
\subsubsection{La fonction \textit{void delete\_game (game g)}}
Elle nous permet de supprimer un jeu en libérant l'espace mémoire qu'il occupait. On supprime chaque pièce du champs \textit{piece} puis la plateau lui-même.
\subsubsection{La fonction \textit{play\_move(game g, int piece\_num, dir d, int distance)}}
Cette fonction tente de déplacer la pièce de numéro \textit{piece\_num} de \textit{distance} cases vers la direction \textit{d}. Si le mouvement est valide, c'est-à-dire qu'à l'issue de son déplacement elle est toujours dans la plateau, qu'elle ne vient pas occuper une case déja prise et que la direction de mouvement lui est permise, alors la pièce est déplacée et le nombre de mouvement effectué est incrémenté. Dans le cas où une des conditions ne serait pas valide, la fonction renvoie \textit{false} et la pièce n'est pas bougée.
On créé donc une autre pièce initialisé avec les valeurs que prendrait la pièce \textit{piece\_num} si elle était déplacée maisqui ne sera pas placée sur le plateau. Elle nous sert à vérifier que la position qu'occuperait la pièce \textit{piece\_num} après déplacement est valide ou non. Si elle est valide on modifie les valeurs de la pièce \textit{piece\_num} et on actualise la numérotation des cases du tableau.
\begin{lstlisting}
bool play_move(game g, int piece_num, dir d, int distance)
{
     if(piece_num>=g->nb_piece || piece_num<0)
	 return false;
  
     int x = get_x(game_piece((cgame)g, piece_num));
     int y = get_y(game_piece((cgame)g, piece_num));
     int p_height = get_height(game_piece((cgame)g, piece_num));
     int p_width = get_width(game_piece((cgame)g, piece_num));

     if(can_move_y((cpiece)g->piece[piece_num]) && (d==UP || d==DOWN))
     {
         int new_h = 0;
         if (d==DOWN)
	 {
	     new_h = y - distance;
	 }
         else
	 {
  	     new_h = y + distance;
	 }
         piece tmp_p = new_piece (x, new_h, p_width, p_height, false, true);
         if (is_in_grid((cgame)g, (cpiece)tmp_p))
	 {
	     for (int i=0; i<game_nb_pieces(g); ++i)
	     {
	         if (piece_num!=i && intersect(tmp_p, g->piece[i]))
		     return false;
	     }
	     move_piece(g->piece[piece_num],d,distance);
	     g->nb_move += distance;
	     positionning(g, (cpiece*)g->piece);
	     return true;
	 }
     }
     if(can_move_x((cpiece)g->piece[piece_num]) && (d==LEFT || d==RIGHT))
     {
         int new_w = 0;
         if (d==LEFT)
	 {
	     new_w = x - distance;
	 }
         else 
	 {
	     new_w = x + distance;
	 }
         piece tmp_p = new_piece (new_w, y, p_width, p_height, true, false);
         if (is_in_grid((cgame)g, (cpiece)tmp_p))
	 {
	     for (int i=0; i<game_nb_pieces(g); ++i)
	     {
	         if (piece_num!=i && intersect(tmp_p, g->piece[i]))
		     return false;
	     }
	     move_piece(g->piece[piece_num],d,distance);
	     g->nb_move += distance;
	     positionning(g, (cpiece*)g->piece);
	     return true;
	 }
     }
     return false;
}
\end{lstlisting}

\subsection{Module affichage}
\subsubsection*{Gestion des erreurs}
En parallèle du découpage effectué, la gestion des erreurs s'est voulue effectuée de façon fluide. Ainsi, un module "manage\_error" regroupe des informations caractéristiques des erreurs (usage de macros pour différents types d'erreurs, de façon la plus précise possible) et une encapsulation pour l'affichage de messages récapitulatifs des erreurs en question lors de leur apparition.
De plus, afin de minimiser l'exécution de sections potentiellement critiques du programme, lorsque cela a été possible les branchements conditionnels ont été effectués afin de prévenir l'exécution de code qui serait compromise par une erreur.
\subsubsection*{Point d'entrée}
Au lancement du programme, l'unité fonctionnelle intitulée "play" prend en charge l'initialisation du programme de la façon suivante :
\begin{itemize}
\item branchement avec le module "data" pour initialiser les champs de la structure qui conservera les données utiles au fil de l'exécution
\item appel du parseur des arguments passés en entrée au programme ("parse\_argv")
\item le parseur effectue un branchement avec le module "opt" dédié à la détection des paramètres en entrée
\end{itemize}
\subsubsection*{Flux d'exécution}
En suite du point d'entrée, la gestion de la partie est transmise à l'unité fonctionnelle "move" qui se chargera de récupérer les instructions utilisateurs, d'effectuer les branchements avec le module "game" et de renvoyer à l'utilisateur la confirmation des modifications par le biais de l'affichage, ce passant par le module "term\_mode", qui prend en charge l'affichage sur terminal en fournissant des outils de lecture/écriture sur celui-ci.

\subsection{Le solveur}

\subsection{Les structures de données}

\subsection{Les tests}

\section{Répartition dans le temps et en espace}
%ici il faut estimer le temps que l'on a passé sur le projet et estimer si la repartion en charge de travail était bien répartie sur tous les membres de groupe
%cette partie est censée emmenée sur les difficultés



\chapter{Les difficultés rencontrées}
\setcounter{section}{0}
%mettre toutes les difficultés que vous avez rencontrés
\section{Au niveau de la V1}

\section{Au niveau de la V2}

\section{Au niveau du solveur}



\chapter{Pour aller plus loin}
\setcounter{section}{0}
\section{Analyse des problèmes rencontrés}

%est-ce qu'il ont été facile a résoudre?

\section{Les améliorations à apporter au projet}
%qu'auriez vous envie de refaire?

\section{Ce que nous à apporter le projet}

\end{document}
