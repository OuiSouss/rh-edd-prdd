\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}

\lstset{language=C, basicstyle=\scriptsize, numbers=left, numberstyle=\footnotesize, numbersep=7pt}

\title{Rapport projet de programmation 2016}
\author{Groupe A1\_2\\Gautier DELACOUR\\Anthony DELASALLE\\Alexis PICHON\\Amélie RISI}
\date{22 Avril 2016}

\begin{document}
\maketitle
\tableofcontents

\chapter{Le projet}
\section{Première version}
Le projet consistait en l'implémentation de plusieurs modules permettant de jouer à jeu de type Rush Hour dont le principe est simple: on dispose d'un tableau de jeu sur lequel sont présentes plusieurs pièces de forme rectangulaire. L'une de ces pièces est la pièce maîtraisse du jeu et il faut déplacer les autres pièces pour amener celle-ci au bord du plateau et ainsi résoudre le puzzle. Cependant chaque pièce ne peu se déplacer soit que horizontalement soit que verticalement.
Dans un premier temps on nous demandait seulement de rendre un version sur terminal du jeu.

\section{Deuxième version}
Par la suite des contraintes se sont ajoutéesau développement du projet. En effet on nous demandait en plus que notre code implémenté pour le Rush Hour soit aussi valable pour un jeu de type Ane Rouge. Ici les pièces peuvent aussi être de forme carrée et n'ont pas forcément de restrictions sur le type de mouvement. De plus, à la différence d'un jeu Rush Hour ou la pièce maîtraisse doit rejoindre le côté droit du plateau pour gagner, la pièce maîtraisse doit ici rejoindre le bas du plateau de jeu pour gagner.
Une fois encore le jeu doit être jouable sur une version terminale mais une interface graphique de base peut maintenant être implémentée, mais elle reste optionnelle.

\section{Le solveur}
Pour terminer un solveur est attendu, permettant bien évidemment de résoudre tout niveau de Rush Hour ou de l'Anne Rouge en fonction des paramètres entrés. Le but est de trouver un algorithme pour résoudre tout jeu de la manière la plus rapide et optimisée possible.



\chapter{Notre conception du projet}
\setcounter{section}{0}
%décrire notre projet
\section{Architecture du projet}
%décrire l'architecture du projet
%que décrit chaque dossier

\section{Les modules}
\subsection*{Module piece.c}
Ce module contient la structure d'une pièce ainsi que toutes les fonctions relatives à ces dernières. C'est ce module qui va nus permettre de créer les pièces de notre jeu, de les modifier (déplacer) ou de les supprimer.
\subsection*{Module game.c}
Ce module contient la structure d'un jeu ainsi que toutes les fonctions qui s'y appliquent. Il nous permet de créer le plateau de jeu, d'y placer les pièces dedans et de les déplacer non plus dans le simple cadre d'une pièce comme pour le module précédant mais dans un envirronement de jeu avec d'autres pièces autour et des limites imposées par les dimensions du plateau.
\subsection*{Module play}
Le rôle rempli par le module \textbf{play} est d'effectuer les branchements avec les modules permettant l'initialisation de la partie, le déroulement de celle-ci et la gestion des erreurs pouvant survenir au cours de l'exécution.
\subsection*{Module data}
Le module \textbf{data.c} est dédié à une encapsulation des informations qui seront necéssaires tout au long de l'exécution pour en assurer le bon déroulement.
\subsection*{Module manage\_error}
Le module \textbf{manage\_error.c} a pour vocation de prendre en charge la gestion des erreurs critiques afin d'effectuer le retour d'informations auprès de l'utilisateur.
\subsection*{Module move}
Le module \textbf{move.c} encapsule la récupération, l'analyse des instructions de l'utilisateur au cours de la partie et la décision à prendre selon la nature de ces instructions.
\subsection*{Module opt}
Le module \textbf{opt.c} est dédié à l'analyse syntaxique des options passées en tant que paramètres au programme lors de son lancement.
\subsection*{Module parse\_file}
Ce module est dédié à la lecture d'un fichier de configuration de la partie passé en paramètre.
\subsection*{Module term\_mode}
Ce module encapsule le service d'affichage de la partie à l'utilisateur sur le terminal.
\subsection*{Module xfunc}
Le module \textbf{xfunc.c} sépare des autres modules des fonctions dont le rôle est l'encapsulation d'appels systèmes dont le temps d'exécution est coûteux.
%Les modules piece et game sont brièvement expliqués, n'hésitais pas ajouter des infos qui vous semblent importantes
%Pour les modules suivant je ne pense pas les maîtriser suffisemment pour en parler, je vous laisse donc le faire



\chapter{Les tests}
\setcounter{section}{0}
%pour Gautier tu sera content comme ça
%decrit tes tests parle de ceux de la V1 et de la V2 ainsi que les derniers de la list chaine seulement car tu as seulement ci ceux la
%explique pourquoi maintenant tu mets des phrases avant chaque action pour dire ce que tu fais à chaque moment
%en gros parle de l'evolution de ton écriture de code
%tu peux sur la fin parler de la tab de hash mais pas trop vu que tu ne l'a pas commit tu en reparlera après



\chapter{Le solveur}
\setcounter{section}{0}
\section{Première approche}
Dans un premier temps, notre approche de la conception du solveur s'est orientée vers l'encadrement du problème.
Il s'agit de trouver une méthode de résolution d'un problème dans l'espace et le temps, le jeu étant en deux dimensions et se déroulant en étapes successives.
Pour ce faire, il a été indispensable de s'interroger sur les structures de données susceptibles de convenir pour le stockage des tours d'une partie.\\
Les contraintes du jeu imposaient de s'intéresser aux structures de données ordonnées, telles que les listes chaînées ou les arbres.
Toutefois, il ne faut pas négliger de prendre en considération que pour un tour donné dans une partie, il existe plusieurs actions possibles.
Cela élimine la possibilité d'utiliser des listes chaînées.\\
L'autre information importante dégagée est relative à la recherche d'un plus court chemin : si un tour donné de la partie permet plusieurs choix, il est également vrai que différents choix de mouvements peuvent mener à une même configuration des pièces.
Parce que ces chemins peuvent être de taille différente, la structure de données choisie est celle d'une table de hachage à adressage chaîné.
L'utilisation d'une table de hachage permet de trier les configurations des pièces indépendament d'un avancement dans le temps.
La structure des clés de hachage correspondant à la position des pièces à une étape donnée :
\begin{itemize}
\item un premier chiffre pour la position en X de la pièce 
\item un second pour la position en Y 
\end{itemize}
Ces coordonnées sont celles de l'angle bas-gauche de la pièce en question
Ce choix d'organisation permet un stockage des tours indépendant de nombre de tours écoulés, qui sont stockés dans chaque chaque cellule de la table.
Les cellules sont organisées de la façon suivante :
\begin{itemize}
\item clé de hachage
\item tableau de pointeurs pour les tours suivants possibles
\end{itemize}

\section{Deuxième approche}
%la je vais écrire cette partie



\chapter{Analyse mémoire}
\setcounter{section}{0}
\section{Valgrind}
%faire une analyse fuite mémoire sur tout notre projet et mettre en annexe capture d'écran
%y a t-il des problèmes de free et tout ça

\section{Couverture de code}
%pareil pour ça



\chapter{Organisation}
\setcounter{section}{0}
\section{Répartition des tâches}
\subsubsection*{Première partie du projet pour la V1}
La première étape du projet nous demandait d'implémenter les modules \textbf{piece.c} et \textbf{game.c} sur lesquels seront effectués des test unitaires. Ces modules contiennent les fonctions qui permettent au jeu de fonctionner, un dernier module gérant l'affichage du jeu sur terminal. Il y avait 4 grands axe à développer et nous nous sommes donc répartis les taches de la sorte:
\begin{description}
\item [Gautier:] implémentation du test unitaire sur game
\item [Anthony:] implémentation du module piece
\item [Alexis:] implémentation du module d'affichage du jeu et liaisons inter modules
\item [Amélie:] implémentation du module game
\end{description}
Par la suite Alexis s'est occupé de structurer notre projet pour un repérage plus facile des fichiers et de faire les Makelists permettant d'obtenir un exécutable.
\subsubsection*{Suite de projet pour la V2}
L'évolution du projet vers la v2 nous demandait de faire en sorte que notre code, qui devait permettre lors de la V1 de jouer à Rush Hour, puisse aussi nous permettre de jouer à l'Ane Rouge. Il a donc fallut revoir les modules \textbf{piece.c} et \textbf{game.c} ainsi que le test unitaire sur \textbf{game.c}. De plus le test unitaire sur \textbf{piece.c} de la V1 n'étant plus en vigueur il a aussi fallut implémenter les test unitaire de ce module.
\begin{description}
\item [Mise à niveau de module game] Amélie
\item [Mise à niveau du module piece] Anthony
\item [Implémentation des tests unitaires] Répartis entre Gautier et Anthony
\item [Implémentation du module d'affichage de l'Ane Rouge] Alexis
\end{description}

\subsection{Module piece}
\subsubsection*{Structure d'une pièce}
Chaque pièce du jeu est défine par les coordonnées (x,y) de son angle bas-gauche, sa hauteur et sa largeur sur le plateau ainsi que par sa faculté à se déplacer de manère verticale et/ou horizontale.
On a donc une structure à six champs qui sont:
\begin{itemize}
\item \textbf{x} un entier correspondant à la coordonnée de l'angle bas-gauche de la pièce sur l'axe des abscisses
\item \textbf{y} un entier correspondant à la coordonnée de l'angle bas-gauche de la pièce sur l'axe des ordonnées
\item \textbf{width} un entier correspondant à la largeur de la pièce
\item \textbf{height} un entier correspondant à la hauteur de la pièce
\item \textbf{move\_x} un booléen indiquant si la pièce peut etre déplacée horizontalement
\item \textbf{move\_y} un booléen indiquant si la pièce peut etre déplacée verticalement
\end{itemize} 
\subsubsection*{La fonction \textit{new\_piece\_rh(int x, int y, bool small, bool horizontal)}}
Cette fonction nous permet de créer une pièce de jeu initialisée aux coordonnées (x,y) entrées en paramètres. Les deux booléens \textit{small} et \textit{horizontal} vont nous permettre à eux deux de déterminer les valeurs des champs \textit{width}, \textit{height}, \textit{move\_x} et \textit{move\_y}. En effet cette fonction n'est valable que dans le cas d'un jeu Rush Hour où les pièces ne peuvent effectuer qu'un seul type de movement et dont la taille (largeur ou hauteur en fonction de son inclinaison) est de 2 ou de 3, le second champs étant à 1.\\
Par exemple une pièce initialisé avec un \textit{small} à \textit{false} et un \textit{horizontal} à \textit{true} aura une largeur de 3 et une hauteur de 2. De plus étant horizontale elle aura \textit{move\_x} à \textit{true} et \textit{move\_y} à \textit{false}.
\begin{lstlisting}
piece new_piece_rh(int x, int y, bool small, bool horizontal)
{
  piece p = malloc(sizeof(*p));
  if (p==NULL)
  {
    fprintf(stderr, "Allocation probleme");
    exit(EXIT_FAILURE);
  }
  p->x = x;
  p->y = y;
  if (horizontal)
  {
    p->width = 3;
    p->height = 1;
    p->move_x = true;
    p->move_y = false;
    if (small)
      p->width -= 1;
  }
  else
  {
    p->width = 1;
    p->height = 3;
    p->move_x = false;
    p->move_y = true;
    if (small)
      p->height -= 1;
  }
  return p;
}
\end{lstlisting}
On se contente ici d'allouer dynamiquement un espace mémoire à cette nouvelle pièce avant de lui attribuer les valeurs souhaitées.
\subsubsection*{La fonction \textit{new\_piece(int x, int y, int width, int height, bool move\_x, bool move\_y)}}
Le principe est le même que la fonction précédante hormis le fait qu'on initialise ici nous-même les valeurs de \textit{width}, \textit{height}, \textit{move\_x} et \textit{move\_y} afin de convenir aux possibilités offertes par un jeu de même type que l'Ane Rouge. Dans ce jeu les pièces n'ont pas de restrictions de dimension en dehors de celles imposées par le plateau de jeu et peuvent se déplacer à la fois en abscisse et en ordonnée.
\subsubsection*{La fonction \textit{delete\_piece(piece p)}}
Simple fonction permettant de supprimer une pièce créée. On se contente de vérifier si la pièce passée en paramètre n'est pas \textit{null} avant de faire un \textit{free} de cette pièce.
\subsubsection*{La fonction \textit{copy\_piece(cpiece src, piece dst)}}
Cette fonction prend deux pièce en paramètre et vérifie si elle ne sont pas \textit{null}. Si le test passe on copie les valeurs de la pièce \textit{src} dans la pièce \textit{dst}. Dans le cas contraire un message d'erreur est affiché pour avertir qu'au moins une des pièces entrées en paramètre ne convient pas.
\subsubsection*{La fonction \textit{move\_piece(piece p, dir d, int distance)}}
Cette fonction nous permet de décaler les coordonnées (x,y) de la pièce entrée en paramètre de \textit{distance} dans la direction \textit{d} choisi. Si on veut bouger la pièce verticalement on modifie la coordonée \textit{y} sinon la coordonnée \textit{x}. La \textit{distance} est additionnée ou soustraite en fonction de la direction. Bien évidemment on vérifie avant toute modification que les champs de la pièce sont en accord avec le déplacement souhaité.
\subsubsection*{La fonction \textit{intersect(cpiece p1, cpiece p2)}}
Dans cette fonction on test si deux pièces entrées en paramètres se croisent, c'est-à-dire si elles occupent une même place sur la plateau, auquel cas elle retourne \textit{true}. Afin de savoir si il y a effectivement intersection ou pas on commence par tester si les deux pièces ont les mêmes coordonnées (x,y): si oui la fonction retourne \textit{true} dès maintenant. Sinon on poursuit en comparant les angles des pièces. Si l'angle de la bas-gauche de la première pièce et situé avant l'angle haut-droit de la seconde pièce et si l'angle haut-droit de la première pièce est aussi situé après l'angle bas-gauche de la seconde pièce alors il y a intersection.
\begin{lstlisting}
bool intersect (cpiece p1, cpiece p2)
{
  if (get_x(p1) == get_x(p2) && get_y(p1) == get_y(p2)) 
    return true;
  int x1=get_x(p1);
  int x2=get_x(p2);
  int y1=get_y(p1);
  int y2=get_y(p2);
  if ((x1 < x2+get_width(p2)) && (x1+get_width(p1) > x2))
    if ((y1 < y2+get_height(p2)) && (y1+get_height(p1) > y2))
      return true;
  return false;
}
\end{lstlisting}

\subsection{Module game}
\subsubsection{Structure d'un jeu}
Le plateau de jeu est définie par ses dimensions hauteur*largeur et l'ensemble de pièces qui le compose. Sa structure est donc composée des champs \textit{board} un tableau 2D représentant le plateau de jeu, les entiers \textit{width} et \textit{height} correspondants respectivement aux dimensions en largeur et en hauteur du plateau ainsi que du champs \textit{piece} qui va contenir toutes pièces qui seront présentes sur le jeu. \\
On dispose également du champs \textit{nb\_piece} pour connaître le nombre exact de pièces présentes en jeu et d'un dernier champs \textit{nb\_move} pour savoir combien de mouvement de pièces ont été réalisé depuis le début du jeu. Ce dernier champs est inclus dans la structure car il est propre à chaque jeu.
\subsubsection{La fonction \textit{new\_game (int width, int height, int nb\_pieces, piece *pieces)}}
Pour créer un nouveau plateau de jeu on initialise un tableau 2D par allocation dynamique de dimension \textit{width} et \textit{height}. On copie ensuite chaque pièces du tableau de pièces passé en paramètre dans le champs \textit{piece} après s'être assuré qu'elle ne soit pas en dehors du plateau. Une fois ces deux étapes effectuées on place les pièces sur le plateau en attribuant à chaque case du plateau le numéro de la pièce qu'il l'occupe ou -1 si aucune pièce n'est présente.
\begin{lstlisting}
game new_game (int width, int height, int nb_pieces, piece *pieces)
{
  if(pieces==NULL || nb_pieces<=0 || pieces[0]==NULL || width<=0 || height<=0)
      return NULL;

  game new_g = malloc (sizeof (*new_g));
  if (new_g==NULL)
      fprintf(stderr,"Problem in the allocation of newGame!!!\n");

  new_g->board = malloc (sizeof(*(new_g->board))*height);
  if (new_g->board==NULL)
      fprintf(stderr, "Problem in the allocation of newGame's board (height)\n");
  for (int j= 0; j<height; ++j)
  {
      new_g->board[j] = (int *) malloc (sizeof(*(new_g->board[j]))*width);
    if (new_g->board[j]==NULL)
      fprintf(stderr, "Probleme in the allocation of newGame's board (width)\n");
  }

  new_g->width = width;
  new_g->height = height;
  new_g->nb_move = 0;
  new_g->nb_piece = 0;

  new_g->piece = malloc (nb_pieces * sizeof(*pieces));
  if (new_g->piece==NULL)
      fprintf(stderr,"Problem in allocation of piece in structure\n");
     
  for (int i=0; i<nb_pieces; ++i)
  {
      if (!is_in_grid(new_g, pieces[i]))
	fprintf(stderr, "Piece %d out of board\n", i);

      new_g->piece[i] = new_piece(get_x(pieces[i]), get_y(pieces[i]), get_width(pieces[i]), get_height(pieces[i]), can_move_x(pieces[i]), can_move_y(pieces[i]));
      new_g->nb_piece += 1;
  }

  positionning(new_g, (cpiece*)new_g->piece);

  if (new_g->nb_piece != nb_pieces)
  {
      delete_game(new_g); // free of all we allocated before
      new_g = NULL;
  }
  return new_g;
}
\end{lstlisting}
\subsubsection{La fonction \textit{game new\_game\_hr (int nb\_piece, piece *piece)}}
Dans ce cas, on créer un jeu dont les conditions sont propres à Rush Hour.
Il s'agit d'un simple appel à la fonction \textit{new\_game} avec les dimensions d'un plateau de Rush Hour.
\subsubsection{La fonction \textit{void delete\_game (game g)}}
Elle nous permet de supprimer un jeu en libérant l'espace mémoire qu'il occupait. On supprime chaque pièce du champs \textit{piece} puis la plateau lui-même.
\subsubsection{La fonction \textit{play\_move(game g, int piece\_num, dir d, int distance)}}
Cette fonction tente de déplacer la pièce de numéro \textit{piece\_num} de \textit{distance} cases vers la direction \textit{d}. Si le mouvement est valide, c'est-à-dire qu'à l'issue de son déplacement elle est toujours dans la plateau, qu'elle ne vient pas occuper une case déja prise et que la direction de mouvement lui est permise, alors la pièce est déplacée et le nombre de mouvement effectué est incrémenté. Dans le cas où une des conditions ne serait pas valide, la fonction renvoie \textit{false} et la pièce n'est pas bougée.\\
On créé donc une autre pièce initialisé avec les valeurs que prendrait la pièce \textit{piece\_num} si elle était déplacée maisqui ne sera pas placée sur le plateau. Elle nous sert à vérifier que la position qu'occuperait la pièce \textit{piece\_num} après déplacement est valide ou non. Si elle est valide on modifie les valeurs de la pièce \textit{piece\_num} et on actualise la numérotation des cases du tableau.
\begin{lstlisting}
bool play_move(game g, int piece_num, dir d, int distance)
{
     if(piece_num>=g->nb_piece || piece_num<0)
	 return false;
  
     int x = get_x(game_piece((cgame)g, piece_num));
     int y = get_y(game_piece((cgame)g, piece_num));
     int p_height = get_height(game_piece((cgame)g, piece_num));
     int p_width = get_width(game_piece((cgame)g, piece_num));

     if(can_move_y((cpiece)g->piece[piece_num]) && (d==UP || d==DOWN))
     {
         int new_h = 0;
         if (d==DOWN)
	 {
	     new_h = y - distance;
	 }
         else
	 {
  	     new_h = y + distance;
	 }
         piece tmp_p = new_piece (x, new_h, p_width, p_height, false, true);
         if (is_in_grid((cgame)g, (cpiece)tmp_p))
	 {
	     for (int i=0; i<game_nb_pieces(g); ++i)
	     {
	         if (piece_num!=i && intersect(tmp_p, g->piece[i]))
		     return false;
	     }
	     move_piece(g->piece[piece_num],d,distance);
	     g->nb_move += distance;
	     positionning(g, (cpiece*)g->piece);
	     return true;
	 }
     }
     if(can_move_x((cpiece)g->piece[piece_num]) && (d==LEFT || d==RIGHT))
     {
         int new_w = 0;
         if (d==LEFT)
	 {
	     new_w = x - distance;
	 }
         else 
	 {
	     new_w = x + distance;
	 }
         piece tmp_p = new_piece (new_w, y, p_width, p_height, true, false);
         if (is_in_grid((cgame)g, (cpiece)tmp_p))
	 {
	     for (int i=0; i<game_nb_pieces(g); ++i)
	     {
	         if (piece_num!=i && intersect(tmp_p, g->piece[i]))
		     return false;
	     }
	     move_piece(g->piece[piece_num],d,distance);
	     g->nb_move += distance;
	     positionning(g, (cpiece*)g->piece);
	     return true;
	 }
     }
     return false;
}
\end{lstlisting}

\subsection{Module affichage}
\subsubsection*{Gestion des erreurs}
En parallèle du découpage effectué, la gestion des erreurs s'est voulue effectuée de façon fluide. Ainsi, un module "manage\_error" regroupe des informations caractéristiques des erreurs (usage de macros pour différents types d'erreurs, de façon la plus précise possible) et une encapsulation pour l'affichage de messages récapitulatifs des erreurs en question lors de leur apparition.
De plus, afin de minimiser l'exécution de sections potentiellement critiques du programme, lorsque cela a été possible les branchements conditionnels ont été effectués afin de prévenir l'exécution de code qui serait compromise par une erreur.
\subsubsection*{Point d'entrée}
Au lancement du programme, l'unité fonctionnelle intitulée "play" prend en charge l'initialisation du programme de la façon suivante :
\begin{itemize}
\item branchement avec le module "data" pour initialiser les champs de la structure qui conservera les données utiles au fil de l'exécution
\item appel du parseur des arguments passés en entrée au programme ("parse\_argv")
\item le parseur effectue un branchement avec le module "opt" dédié à la détection des paramètres en entrée
\end{itemize}
\subsubsection*{Flux d'exécution}
En suite du point d'entrée, la gestion de la partie est transmise à l'unité fonctionnelle "move" qui se chargera de récupérer les instructions utilisateurs, d'effectuer les branchements avec le module "game" et de renvoyer à l'utilisateur la confirmation des modifications par le biais de l'affichage, ce passant par le module "term\_mode", qui prend en charge l'affichage sur terminal en fournissant des outils de lecture/écriture sur celui-ci.

\subsection{Module play}
\subsubsection*{Point d'entrée}
Dans un premier temps, le main, notre point d'entrée dans le programme, voit son contenu varier suivant l'exécutable généré : des macros sont présentes pour que la compilation utilise le bon code pour générer l'exécutable du rush-hour ou de l'âne rouge.
Ensuite, le main effectue dans les deux cas les étapes suivantes :
\begin{itemize}
\item branchement avec le module \textbf{data.c} pour initialiser les champs de la structure associée qui permettra la transmission des informations utiles au cours de l'exécution 
\item appel de la fonction \textit{parse\_argv} pour la gestion des paramètres du programme 
\item branchement conditionnel sous la forme d'une boucle avec la fonction \textit{game\_loop} dédiée à la gestion du flux d'exécution tout au long de la partie 
\item en cas d'erreur critique, un branchement est effectué avec le module \textbf{manage\_error.c} 
\item avant la fin du programme, un second branchement est effectué avec le module \textbf{data.c} afin de libérer la mémoire allouée dynamiquement au cours de l'initialisation
\end{itemize}
\subsubsection*{La fonction \textit{parse\_argv(struct s\_data* data)}}
La fonction \textit{parse\_argv} est une encapsulation du parseur des arguments passés au programme lors de son lancement.
Elle va de ce fait analyser les arguments passés au programme afin d'en extraire les informations utiles au déroulement de la partie.
Ceci est effectué par le biais de branchements avec le module \textbf{opt.c}, dont l'objectif est de détecter et récupérer les paramètres necéssaires.
\subsubsection*{La fonction \textit{game\_loop(struct s\_data* data)}}
La fonction intitulée \textit{game\_loop} a pour vocation d'encapsuler le flux d'exécution lié au déroulement de la partie.\\
Le principe est le suivant :
\begin{itemize}
\item lors du premier appel se produit l'étape finale d'initialisation, à savoir un branchement au module \textbf{game.c} effectué par un appel de la fonction \textit{new\_game}
\item les appels à cette fonction au cours de la boucle d'exécution correspondent à un branchement avec le module d'affichage \textbf{term\_mode} (appel de \textit{printout\_game}) qui sera suivi d'un branchement avec le module \textbf{move.c} pour récupérer les instructions de déplacement de l'utilisateur sur le tour en cours.
\end{itemize}

\subsection{Module data}
\subsubsection*{La fonction \textit{init\_data(struct s\_data* data, int *argc, char** argv, bool (*game\_over)(cgame))}}
La fonction \textit{init\_data} permet d'initialiser les champs de la structure qui conservera la garde des informations necéssaires au programme pour son bon fonctionnement.
Cela correspond aux paramètres du programme, mais également à la fonction qui permettra au programme de savoir si une partie est terminée ou non.
\subsubsection*{La fonction \textit{delete\_data(struct s\_data* data)}}
Cette fonction est destinée à être appelée lorsque le programme est en fin de vie, ce afin de libérer la mémoire allouée dynamiquement au cours de l'exécution.

\subsection{Module manage\_error}
\subsubsection{La fonction \textit{manage\_error(struct s\_data* data)}}
La fonction \textit{manage\_error} synthétise ce service et affichera donc un message d'erreur approprié pour informer l'utilisateur de la nature d'une erreur critique survenue.
De plus, ce module fournit des macros permettant à l'utilisateur de différencier les erreurs critiques entre elles (erreur de paramètre du programme, erreur d'allocation mémoire, ...).

\subsection{Module move}
\subsubsection*{La fonction \textit{manage\_move(struct s\_data* data)}}
La fonction \textit{manage\_move} encapsule la récupération de ces instructions en invoquant la fonction \textit{manage\_piece}.
\subsubsection*{La fonction \textit{manage\_piece(struct s\_data* data, char* buffer)}}
La fonction \textit{manage\_piece} récupère le numéro de la pièce que l'utilisateur souhaite déplacer.
Si un numéro de pièce invalide est entré ou si la lecture sur l'entrée standard de ce numéro a échoué, elle transmet cette information à l'utilisateur et se termine.
Lorsqu'un numéro valide est récupéré, la fonction "manage\_dir" est alors appélée.
\subsubsection*{La fonction \textit{manage\_dir(struct s\_data* data, const int nb\_pc, char* buffer)}}
La fonction \textit{manage\_dir} a pour vocation la récupération de la direction du mouvement de la pièce choisie par l'utilisateur.
En cas de mouvement invalide ou si la récupération de cette information échoue, cette fonction se termine.
Dans le cas d'un mouvement valide, la fonction effectue un branchement avec le module \textbf{game.c} en appelant la fonction \textit{play\_move} avec les paramètres récupérés précédement.

\subsection{Module opt}
\subsubsection*{Les fonctions \textit{is\_opt(const char* s)} et \textit{parse\_opt(struct s\_data* data)}}
Dans un premier temps, la fonction \textit{is\_opt} tente de détecter si le paramètre en cours d'analyse est une option du programme.
Ultérieurement à cette vérification, la fonction \textit{parse\_opt} va récupérer le paramètre et le traiter de façon appropriée (appel de la fonction \textit{parse\_input\_file} du module \textbf{parse\_file.c} par exemple).

\subsection{Module parse\_file}
\subsubsection*{La fonction \textit{parse\_input\_file(struct s\_data* data)}}
La fonction \textit{parse\_input\_file} encapsule le service rendu par le module \textbf{parse\_file.c}.
Elle va se contenter de lire le fichier passé en paramètre afin de récupérer les informations qu'il contient.

\subsection{Module term\_mode}
\subsubsection*{La fonction \textit{printout\_game(struct s\_data* data)}}
La fonction \textit{printout\_game} synthétise le service rendu par le module d'affichage en utilisant les données qui lui sont transmises au sein de notre structure globale de stockage des informations.

\subsection{Module xfunc}
Le module \textbf{xfunc.c} sépare des autres modules des fonctions dont le rôle est l'encapsulation d'appels systèmes dont le temps d'exécution est coûteux.
\subsubsection*{Fonction \textit{xmalloc(const unsigned int size, int* status)}}
Cette fonction fournit une encapsulation de l'appel système \textit{malloc} et réduit les branchements effectués avec celui-ci, en l'occurence en évitant l'appel lorsque la taille du bloc mémoire à allouer dynamiquement est nulle.
De plus, cette fonction a également l'avantage de fournir un second retour à l'utilisateur lorsqu'une erreur survient. En effet, un second paramètre est présent pour qu'à l'adresse qu'il renseigne il soit possible de spécifier qu'il y a eu une erreur.
\subsubsection*{Fonction \textit{xfree(void** ptr)}}
La fonction \textit{xfree} encapsule l'appel système \textit{free} qui n'est alors effectué que lorsque l'on passe l'adresse d'une adresse mémoire valide.
De plus, le passage de l'adresse où est stocké l'adresse du bloc mémoire à libérer permet de sécuriser ce traitement en modifiant l'adresse où est stockée cette information, qui contiendra alors en sortie de fonction l'adresse du pointeur nul.
L'objectif de ce double traitement est de réduire au maximum les branchements avec le noyau (invocation de l'appel système \textit{free}) ainsi que de supprimer le besoin de traitement supplémentaire en dehors de cette fonction (la variable qui contenait l'adresse de la mémoire à libérer contient donc l'adresse du pointeur nul après libération).

\subsection{Le solveur}
% A faire

\subsection{Les structures de données}
% A faire

\subsection{Les tests}
% A faire

\section{Répartition dans le temps et en espace}
\subsection*{Alexis}
La répartition du travail que j'ai effectué au cours du projet est la suivante :\\
- en espace :
\begin{itemize}
\item implémentation du squelette du programme : point d'entrée, initialisation et fin de vie du programme, branchements avec les modules \textbf{game.c} et \textbf{piece.c}
\item implémentation de l'interation avec l'utilisateur : gestion des paramètres, interaction sur l'entrée pour récupérer les instructions utilisateur
\item implémentation de l'affichage.
\end{itemize}
- en temps :
\begin{itemize}
\item
- le travail requis pour l'implémentation des parties mentionnées ci-dessus représente un volume horaire compris entre 30 et 40 heures 
\item
- le volume de travail necéssaire pour parvenir à concevoir cette structure représente quand à lui un volume horaire situé entre 10 et 20 heures 
\item
- le volume de travail ayant conduit à l'élaboration des branchements entre les différents modules (en dehors des branchements déjà proposés entre les modules \textbf{game.c} et \textbf{piece.c}) se situe entre 10 et 20 heures.
\end{itemize}



\chapter{Les difficultés rencontrées}
\setcounter{section}{0}
\section{Au niveau de la V1}
De problèmes au niveau du raisonnement sur l'algorithme de la fonction \textit{intersect (cpiece p1, cpiece p2)} du module \textbf{piece.c} ont demandé un certain temps avant d'être réglés, nécessitant de revoir à plusieurs reprise l'approche de cet algorithme. Ce n'était au final que de simples erreurs de raisonnement où certains cas dans lesquels deux pièces se chevauchaient n'étaient pas pris en compte, faussant le résultat.\\
Des problèmes au niveau du module \textbf{game.c} ont aussi été observés, notamment des fuites mémoires dues à des allocations dynamiques mal gérées.\\
L'absence d'une option permettant de savoir si une pièce se trouve sur une case donnée du tableau en connaissant uniquement les coordonnées de la case a rendu très difficile l'implémentation de l'affichage.
De plus, cela a également requis de conserver en dehors de la structure de données associée au module \textbf{game.c} les informations relatives au plateau, à savoir quelle pièce se trouve à telle case.\\
L'absence d'une configuration proposée pour la prise en charge d'un fichier de configuration a également ralenti le développement du programme.

\section{Au niveau de la V2}
L'absence d'un formatage proposé pour les fichiers de configuration a rendu laborieux l'implémentation des modifications.
De plus, le caractère statique de la bibliothèque associé au module \textbf{game.c} a requis d'en extraire la différentiation entre le rush-hour et l'âne rouge et de l'intégrer ailleurs.

\section{Au niveau du solveur}
% A faire



\chapter{Pour aller plus loin}
\setcounter{section}{0}
\section{Analyse des problèmes rencontrés}

%est-ce qu'il ont été facile a résoudre?

\section{Les améliorations a apporter au projet}
Il est raisonnable de penser que préférer la programmation Objet à la programmation Fonctionnelle aurait notablement réduit la quantité de travail nécessaire pour parvenir à un même résultat.
Le paradigme Objet est très bien illustré par les modules \textbf{game.c} et \textbf{piece.c} dont l'encapsulation des données et les services rendus par les fonctions qu'ils contiennent correspondent au fonctionnement d'un Objet.
De plus, le maintient et la portabilité du code produit auraient été facilités.\\
Dans cette optique d'optimisation, il aurait également été envisageable de choisir une implémentation Objet pour les modules \textbf{game.c} et \textbf{piece.c} tout en conservant une approche fonctionnelle pour le reste du programme (point d'entrée du programme, interactions entrée/sortie et branchements avec les modules \textbf{game.c} et \textbf{piece.c}).

\section{Ce que nous a apporté le projet}
% A faire

\end{document}
