\documentclass{report}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[francais]{babel}
\usepackage{listings}

\lstset{language=C, basicstyle=\scriptsize, numbers=left, numberstyle=\footnotesize, numbersep=7pt}

\title{Rapport projet de programmation 2016}
\author{Groupe A1\_2\\Gautier DELACOUR\\Anthony DELASALLE\\Alexis PICHON\\Amélie RISI}


\begin{document}
\maketitle
\tableofcontents

\chapter{Le projet}
Ce projet a été réalisé dans le cadre d'une UE. Le but était de créer un jeu Rush Hour ou similaire à celui-ci à l'aide du langage de programmation C.
\section{Première version}
Le projet consistait en l'implémentation de plusieurs modules permettant de jouer à jeu de type Rush Hour dont le principe est simple: on dispose d'un tableau de jeu sur lequel sont présentes plusieurs pièces de forme rectangulaire. L'une de ces pièces est la pièce maîtraisse du jeu et il faut déplacer les autres pièces pour amener celle-ci au bord du plateau et ainsi résoudre le puzzle. Cependant chaque pièce ne peut se déplacer soit que horizontalement soit que verticalement.\\
Dans cette première version, il nous était demandé de fournir seulement une interface pour un terminal.

\section{Deuxième version}
Par la suite des contraintes se sont ajoutéesau développement du projet. En effet on nous demandait en plus que notre code implémenté pour le Rush Hour soit aussi valable pour un jeu de type Ane Rouge. Ici les pièces peuvent aussi être de forme carrée et n'ont pas forcément de restrictions sur le type de mouvement. De plus, à la différence d'un jeu Rush Hour ou la pièce maîtraisse doit rejoindre le côté droit du plateau pour gagner, la pièce maîtraisse doit ici rejoindre le bas du plateau de jeu pour gagner.\\
Une fois encore le jeu doit être jouable sur une version terminale mais une interface graphique de base peut maintenant être implémentée, mais elle reste optionnelle.

Une fois encore le jeu doit être jouable sur une version terminal mais une interface graphique de base peut maintenant être implémentée, mais elle reste optionnelle.


\section{Le solveur}
Pour terminer un solveur est attendu, permettant bien évidemment de résoudre tout niveau de Rush Hour ou de l'Ane Rouge en fonction des paramètres entrés. Le but est de trouver un algorithme pour résoudre tout jeu de la manière la plus rapide et optimisée possible.


\chapter{Notre conception du projet}
\setcounter{section}{0}
Lors de notre conception du projet, nous avons eu pour but d'essayer de respecter les réglementations au niveau, par exemple, des headers initiaux que l'on avait pas le droit de modifiés et de test unitaires  à créer. De plus, nous avions décidés de créer une interface terminal qui soit protéger au niveau des erreurs de saisies d'argument par exemple. Néanmoins, suite à certain problème, nous n'avons pas pu délivré notre travail de la V1 dans les temps impartit avec tous les objectifs remplit. De même, lors de la réalisation de la deuxième version du projet, nous avons aussi eu des problèmes pour créer des exécutables pour l'âne rouge et le rush hour qui soit fonctionnels. Pour finir, notre solveur est complément néant suite à un manque d'organisation dans le groupe.\\
Pour ce projet, nous avons décidé d'utiliser un dépôt svn et cmake pour compiler notre projet.

\section{Architecture du projet}
Notre projet s'articule autour de la V1 et de la V2. Nous avons séparé les deux versions suite à la modification des headers \textbf{piece.h} et \textbf{game.h} lors du changement des spécifications.\\
Voici la structure de la V1:
\begin{description}
\item [Build :] Dossier qui permet de créer tous les fichiers liés à cmake et la compilation.
\item [Include :] Dossier pour tous les headers.
\item [Lib :] Dossier où toutes les libs sont après leur création
\item [Src :] Dossier où se trouvent tous nos .c. Ce dossier est organisé comme suit :
  \begin{itemize}
  \item [Game :] Ce dossier décrit toutes foctionnnalité liée à un jeu de Rush Hour, c'est-à-dire les pièces et le game ainsi que les tests unitaires de ces modules.
  \item [Rush Hour :] Ce dossier décrit le rush hour, c'est-à-dire il n'y a qu'un main dans le fichiers .c qui crée un jeu de rush hour. 
  \item [Exec :] Ce dossier décrit l'excution d'un jeu.
  \item [Io\_interface :] Ce dossier décrit l'interface sur le terminal.
  \end{itemize}
\end{description}

Dans la V2, la structure est similaire pour cette version mise à part que l'on a regroupé tout ce que est pour l'interface terminal dans un dossier exec et nous avons ajouté pour le solveur un dossier data, inclut dans le dossier src, qui contient toutes les structures de données pour notre solveur.

\section{Les modules}
\subsection*{Module piece}
Le module \textbf{piece} contient la structure d'une pièce ainsi que toutes les fonctions relatives à ces dernières. C'est ce module qui va nous permettre de créer les pièces de notre jeu, de les modifier (déplacer) ou de les supprimer.
\subsection*{Module game}
Le module \textbf{game} contient la structure d'un jeu ainsi que toutes les fonctions qui s'y appliquent. Il nous permet de créer le plateau de jeu, d'y placer les pièces dedans et de les déplacer non plus dans le simple cadre d'une pièce comme pour le module précédent mais dans un environnement de jeu avec d'autres pièces autour et des limites imposées par les dimensions du plateau.
\subsection*{Module play}
Le rôle rempli par le module \textbf{play} est d'effectuer les branchements avec les modules permettant l'initialisation de la partie, le déroulement de celle-ci et la gestion des erreurs pouvant survenir au cours de l'exécution.
\subsection*{Module data}
Le module \textbf{data} est dédié à une encapsulation des informations qui seront necéssaires tout au long de l'exécution pour en assurer le bon déroulement.
\subsection*{Module manage\_error}
Le module \textbf{manage\_error} a pour vocation de prendre en charge la gestion des erreurs critiques afin d'effectuer le retour d'informations auprès de l'utilisateur.
\subsection*{Module move}
Le module \textbf{move} encapsule la récupération, l'analyse des instructions de l'utilisateur au cours de la partie et la décision à prendre selon la nature de ces instructions.
\subsection*{Module opt}
Le module \textbf{opt} est dédié à l'analyse syntaxique des options passées en tant que paramètres au programme lors de son lancement.
\subsection*{Module parse\_file}
Le module \textbf{parse file} est dédié à la lecture d'un fichier de configuration de la partie passé en paramètre.
\subsection*{Module term\_mode}
Le module \textbf{term mode} encapsule le service d'affichage de la partie à l'utilisateur sur le terminal.
\subsection*{Module xfunc}
Le module \textbf{xfunc.c} sépare des autres modules des fonctions dont le rôle est l'encapsulation d'appels systèmes dont le temps d'exécution est coûteux.
\subsection*{Module list}
Le module \textbf{list.c} est dédié au solveur. Son but est de définir les fonctions utiles pour l'utilisation d'une liste simplement chainée.


\chapter{Le solveur}
\setcounter{section}{0}
\section{Première approche}
Dans un premier temps, notre approche de la conception du solveur s'est orientée vers l'encadrement du problème.
Il s'agit de trouver une méthode de résolution d'un problème dans l'espace et le temps, le jeu étant en deux dimensions et se déroulant en étapes successives.
Pour ce faire, il a été indispensable de s'interroger sur les structures de données susceptibles de convenir pour le stockage des tours d'une partie.\\
Les contraintes du jeu imposaient de s'intéresser aux structures de données ordonnées, telles que les listes chaînées ou les arbres.
Toutefois, il ne faut pas négliger de prendre en considération que pour un tour donné dans une partie, il existe plusieurs actions possibles.
Cela élimine la possibilité d'utiliser des listes chaînées.\\
L'autre information importante dégagée est relative à la recherche d'un plus court chemin : si un tour donné de la partie permet plusieurs choix, il est également vrai que différents choix de mouvements peuvent mener à une même configuration des pièces.
Parce que ces chemins peuvent être de taille différente, la structure de données choisie est celle d'une table de hachage à adressage chaîné.
L'utilisation d'une table de hachage permet de trier les configurations des pièces indépendamment d'un avancement dans le temps.
La structure des clés de hachage correspondant à la position des pièces à une étape donnée :
\begin{itemize}
\item un premier chiffre pour la position en X de la pièce 
\item un second pour la position en Y 
\end{itemize}
Ces coordonnées sont celles de l'angle bas-gauche de la pièce en question
Ce choix d'organisation permet un stockage des tours indépendant de nombre de tours écoulés, qui sont stockés dans chaque chaque cellule de la table.
Les cellules sont organisées de la façon suivante :
\begin{itemize}
\item clé de hachage
\item tableau de pointeurs pour les tours suivants possibles
\end{itemize}

\section{Deuxième approche}
Dans un deuxième temps, suite à un manque de temps, nous avons réfléchit à une nouvelle approche plus algorithmique cette fois-ci. Néanmoins, cet algorithme n'a pas été fini d'écrire dans les temps imparti et ne semblait fonctionné que sur un jeu de Rush Hour.\\
Notre algorithme était donc :
\begin{itemize}
\item d'abord on regarde si le pièce 0 est bloquée pour sortir ou  non si elle est bloquée, l'ajoute à une liste chainée. Sinon, on la fait sortir.
\item on regarde toutes les pièces qui bloquent la ligne de la sortie pour la pièce maîtresse et on les place dans un tableau, on fait ceci jusqu'à ce qu'il n'y ai plus de pièce qui bloque la sortie de la pièce maîtresse.
\item on sélectionne la plus proche de la sortie.
\item on regarde si elle est bloqué ou non, c'est-à-dire peut-on la déplacée assez pour qu'elle ne bouche plus la sortie.
\item si elle n'est pas bloquée, on l'a bouge
\item si elle est bloquée, on la marque, c'est-à-dire que dans un tableau de la taille du nombre de pièce du jeu, on met un marqueur a true à la place du numéro de la  pièce pour signaler que la pièce est bloquée et qu'on l'a déjà visitée.
\item ensuite, on insère la pièce bloquée dans la liste simplement chainée ou une pile (mais pour cela il aurait fallut implémenté une pile), avec le type de déplacement qu'il faut effectuer, et le nombre de case pour débloqué la situation. A chaque fois, qu'une pièce est bloquée, on l'insère en tête de la liste chainée c'est pour cela qu'une pile serait plus judicieuse.
\item maintenant comme cette pièce est bloquée, on doit sélectionner une pièce qui est sur la ligne horizontale ou verticale selon l'orientation de la pièce bloquée. Pour cela, il faut regarder tous les numéros de pièces les plus proches .
\item si on trouve une pièce proche et qui n'est pas marquée alors on va regarder si elle est bloquée, la déplacée si possible et la marquée sinon et l'ajouter en tête à la liste chaînée.
\item dès qu'une pièce bouge, on regarde le premier élément de la liste chaînée et on essaye de le déplacé à l'aide des informations stockée dans celle-ci.
\item si elle peut bouger, on la déplace, on la démarque et on enlève le premier élément de la liste chaînée.
\item et on fait comme ça jusqu'à ce qu'il ne reste plus que le pièce 0 dans la liste simplement chaînée et que l'on puisse la sortir. Si elle ne peut pas sortir, on retourne au deuxième tiret. 
\end{itemize}

Notre algorithme était donc :
\begin{itemize}
\item d'abord on regarde si le pièce 0 est bloquée pour sortir ou  non si elle est bloquée, l'ajoute à une liste chainée. Sinon, on la fait sortir.
\item on regarde toutes les pièces qui bloquent la ligne de la sortie pour la pièce maîtresse et on les place dans un tableau, on fait ceci jusqu'à ce qu'il n'y ai plus de pièce qui bloque la sortie de la pièce maîtresse.
\item on sélectionne la plus proche de la sortie.
\item on regarde si elle est bloqué ou non, c'est-à-dire peut-on la déplacée assez pour qu'elle ne bouche plus la sortie.
\item si elle n'est pas bloquée, on l'a bouge
\item si elle est bloquée, on la marque, c'est-à-dire que dans un tableau de la taille du nombre de pièce du jeu, on met un marqueur a true à la place du numéro de la  pièce pour signaler que la pièce est bloquée et qu'on l'a déjà visitée.
\item ensuite, on insère la pièce bloquée dans la liste simplement chainée ou une pile (mais pour cela il aurait fallut implémenté une pile), avec le type de déplacement qu'il faut effectuer, et le nombre de case pour débloqué la situation. A chaque fois, qu'une pièce est bloquée, on l'insère en tête de la liste chainée c'est pour cela qu'une pile serait plus judicieuse.
\item maintenant comme cette pièce est bloquée, on doit sélectionner une pièce qui est sur la ligne horizontale ou verticale selon l'orientation de la pièce bloquée. Pour cela, il faut regarder tous les numéros de pièces les plus proches .
\item si on trouve une pièce proche et qui n'est pas marquée alors on va regarder si elle est bloquée, la déplacée si possible et la marquée sinon et l'ajouter en tête à la liste chaînée.
\item dès qu'une pièce bouge, on regarde le premier élément de la liste chaînée et on essaye de le déplacé à l'aide des informations stockée dans celle-ci.
\item si elle peut bouger, on la déplace, on la démarque et on enlève le premier élément de la liste chaînée.
\item et on fait comme ça jusqu'à ce qu'il ne reste plus que le pièce 0 dans la liste simplement chaînée et que l'on puisse la sortir. Si elle ne peut pas sortir, on retourne au deuxième tiret. 
\end{itemize}

\chapter{Analyse mémoire}
\setcounter{section}{0}
\section{Valgrind}
Suite à l'analyse \textbf{Valgrind} de nos exécutables, il en ressort que nos jeux \textbf{rush-hour-v2} et \textbf{ane-rouge} n'ont aucunes fuites mémoires.\\
En revanche, nos tests unitaires sur les modules \textbf{game.c} et \textbf{piece.c} ont des fuites mémoires dues aux variables créées pour les besoins des test qui ne sont pas libérées après leur utilisation. Ces fuites sont plus présentes dans les test unitaires sur \textbf{game.c} que sur \textbf{piece.c}.\\
La dernière analyse \textbf{Valgrind} est réalisée sur l'exécutable du module \textbf{test-list.c}. Celui-ci n'a pas de fuites mémoires mais semble en revanche pointer une erreur sur la fonction \textit{earase\_first} du module \textbf{list.c}.\\
Ces erreurs sont analysées plus bas, dans la partie \textbf{Analyse des problèmes rencontrés} et des capture de chaque analyse effectuée sont disponibles en annexe.

\section{Couverture de code}
Une couvertue de code à été réalisée avec \textbf{Gcov}, nous informant que notre code est convenablement couvert.\\
L'ensemble de nos lignes de code des modules \textbf{game.c} et \textbf{piece.c} ainsi que celles des tests unitaires sur ces modules sont lues à l'exécution, il n'y a donc pas de morceaux de code inutiles. Les seules lignes de codes de codes n'étant pas lues sont celles traitant les cas d'erreurs.\\
Il y a toutefois une exception dans le cas du module \textbf{game.c} et de son test unitaire pour la fonction \textit{copy\_game}. En effet celle-ci ne passait pas le test mit en place dans le module \textbf{test\_game.c}. La partie du test sur cette fonction à donc été mise en commentaire afin d'effectuer les tests suivant, ce qui explique le fait que les lignes de code correspondant à cette fonction et àa son test ne soit pas lues.\\
Les couvertures de code réalisées sont fournies en annexe de ce rapport.



\chapter{Organisation}
\setcounter{section}{0}
\section{Répartition des tâches}
\subsubsection*{Première partie du projet pour la V1}
La première étape du projet nous demandait d'implémenter les modules \textbf{piece.c} et \textbf{game.c} sur lesquels seront effectués des tests unitaires. Ces modules contiennent les fonctions qui permettent au jeu de fonctionner, un dernier module gérant l'affichage du jeu sur terminal. Il y avait 4 grands axe à développer et nous nous sommes donc répartis les taches de la sorte:
\begin{description}
\item [Gautier:] implémentation du test unitaire sur game
\item [Anthony:] implémentation du module piece
\item [Alexis:] implémentation du module d'affichage du jeu et liaisons inter modules
\item [Amélie:] implémentation du module game
\end{description}
Par la suite Alexis s'est occupé de structurer notre projet pour un repérage plus facile des fichiers et de faire les CMakelists permettant d'obtenir un exécutable.
\subsubsection*{Suite de projet pour la V2}
L'évolution du projet vers la V2 nous demandait de faire en sorte que notre code, qui devait permettre lors de la V1 de jouer à Rush Hour, puisse aussi nous permettre de jouer à l'Ane Rouge. Il a donc fallut revoir les modules \textbf{piece.c} et \textbf{game.c} ainsi que le test unitaire sur \textbf{game.c}. De plus, le test unitaire sur \textbf{piece.c} de la V1 n'étant plus en vigueur il a aussi fallut implémenter les tests unitaires de ce module.
\begin{description}
\item [Mise à niveau de module game] Amélie
\item [Mise à niveau du module piece] Anthony
\item [Implémentation des tests unitaires] Répartis entre Gautier et Anthony
\item [Implémentation du module d'affichage de l'Ane Rouge] Alexis
\end{description}
\subsubsection*{Après la V2 et le Solveur}
Suite au rendu de la V2, certaine partie n'étant pas au point, nous avons décidé de résoudre les problèmes et de nous attaquer au solveur donc voici comment nous nous sommes répartit les tâches:
\begin{description}
\item [Résolution des problèmes de la V2 au niveau de game] Anthony
\item [Résolution petit problémes dans les tests unitaires de game] Gautier
\item [Implémentation de structure de données pour le solveur] Amélie: Liste simplement chaînée et Gautier: Table de hachage
\item [Tests unitaire pour les structures de données] Gautier
\item[Tentative de solveur]Amélie
\end{description}

\subsubsection*{Après la V2 et Solveur}
Suite au rendu de la V2, certaine partie n'étant pas au point, nous avons décidé de résoudre les problèmes et de nous attaquer au solveur donc voici comment nous nous sommes répartit les tâches:

\begin{description}
\item [Résolution des problèmes de la V2 au niveau de game] Anthony
\item [Résolution petit problémes dans les tests unitaires de game] Gautier
\item [Implémentation de structure de données pour le solveur] Amélie: Liste simplement chaînée et Gautier: Table de hachage
\item [Tests unitaire pour les structures de données] Gautier
\item[Tentative de solveur]Amélie
\end{description}

\subsection{Module piece}
\subsubsection*{Structure d'une pièce}
Chaque pièce du jeu est défine par les coordonnées (x,y) de son angle bas-gauche, sa hauteur et sa largeur sur le plateau ainsi que par sa faculté à se déplacer de manière verticale et/ou horizontale.
On a donc une structure à six champs qui sont:
\begin{itemize}
\item \textbf{x} un entier correspondant à la coordonnée de l'angle bas-gauche de la pièce sur l'axe des abscisses
\item \textbf{y} un entier correspondant à la coordonnée de l'angle bas-gauche de la pièce sur l'axe des ordonnées
\item \textbf{width} un entier correspondant à la largeur de la pièce
\item \textbf{height} un entier correspondant à la hauteur de la pièce
\item \textbf{move\_x} un booléen indiquant si la pièce peut etre déplacée horizontalement
\item \textbf{move\_y} un booléen indiquant si la pièce peut etre déplacée verticalement
\end{itemize} 
\subsubsection*{La fonction \textit{new\_piece\_rh(int x, int y, bool small, bool horizontal)}}
Cette fonction nous permet de créer une pièce de jeu initialisée aux coordonnées (x,y) entrées en paramètres. Les deux booléens \textit{small} et \textit{horizontal} vont nous permettre à eux deux de déterminer les valeurs des champs \textit{width}, \textit{height}, \textit{move\_x} et \textit{move\_y}. En effet, cette fonction n'est valable que dans le cas d'un jeu Rush Hour où les pièces ne peuvent effectuer qu'un seul type de mouvement et dont la taille (largeur ou hauteur en fonction de son inclinaison) est de 2 ou de 3, le second champs étant à 1.\\
Par exemple, une pièce initialisé avec un \textit{small} à \textit{false} et un \textit{horizontal} à \textit{true} aura une largeur de 3 et une hauteur de 2. De plus, étant horizontale, elle aura \textit{move\_x} à \textit{true} et \textit{move\_y} à \textit{false}.
\begin{lstlisting}
piece new_piece_rh(int x, int y, bool small, bool horizontal)
{
  piece p = malloc(sizeof(*p));
  if (p==NULL)
  {
    fprintf(stderr, "Allocation probleme");
    exit(EXIT_FAILURE);
  }
  p->x = x;
  p->y = y;
  if (horizontal)
  {
    p->width = 3;
    p->height = 1;
    p->move_x = true;
    p->move_y = false;
    if (small)
      p->width -= 1;
  }
  else
  {
    p->width = 1;
    p->height = 3;
    p->move_x = false;
    p->move_y = true;
    if (small)
      p->height -= 1;
  }
  return p;
}
\end{lstlisting}
On se contente ici d'allouer dynamiquement un espace mémoire à cette nouvelle pièce avant de lui attribuer les valeurs souhaitées.
\subsubsection*{La fonction \textit{new\_piece(int x, int y, int width, int height, bool move\_x, bool move\_y)}}
Le principe est le même que la fonction précédente hormis le fait qu'on initialise ici nous-même les valeurs de \textit{width}, \textit{height}, \textit{move\_x} et \textit{move\_y} afin de convenir aux possibilités offertes par un jeu de même type que l'Ane Rouge. Dans ce jeu, les pièces n'ont pas de restrictions de dimension en dehors de celles imposées par le plateau de jeu et peuvent se déplacer à la fois en abscisse et en ordonnée.
\subsubsection*{La fonction \textit{delete\_piece(piece p)}}
Simple fonction permettant de supprimer une pièce créée. On se contente de vérifier si la pièce passée en paramètre n'est pas \textit{null} avant de faire un \textit{free} de cette pièce.
\subsubsection*{La fonction \textit{copy\_piece(cpiece src, piece dst)}}
Cette fonction prend deux pièces en paramètre et vérifie si elle ne sont pas \textit{null}. Si le test passe, on copie les valeurs de la pièce \textit{src} dans la pièce \textit{dst}. Dans le cas contraire, un message d'erreur est affiché pour avertir qu'au moins une des pièces entrées en paramètre ne convient pas.
\subsubsection*{La fonction \textit{move\_piece(piece p, dir d, int distance)}}
Cette fonction nous permet de décaler les coordonnées (x,y) de la pièce entrée en paramètre de \textit{distance} dans la direction \textit{d} choisi. Si on veut bouger la pièce verticalement, on modifie la coordonnée \textit{y} sinon la coordonnée \textit{x}. La \textit{distance} est additionnée ou soustraite en fonction de la direction. Bien évidemment, on vérifie avant toute modification que les champs de la pièce sont en accord avec le déplacement souhaité.
\subsubsection*{La fonction \textit{intersect(cpiece p1, cpiece p2)}}
Dans cette fonction, on teste si deux pièces entrées en paramètres se croisent, c'est-à-dire si elles occupent une même place sur la plateau, auquel cas elle retourne \textit{true}. Afin de savoir si il y a effectivement intersection ou pas, on commence par tester si les deux pièces ont les mêmes coordonnées (x,y): si oui la fonction retourne \textit{true} dès maintenant. Sinon on poursuit en comparant les angles des pièces. Si l'angle bas-gauche de la première pièce et situé avant l'angle haut-droit de la seconde pièce et si l'angle haut-droit de la première pièce est aussi situé après l'angle bas-gauche de la seconde pièce alors il y a intersection.
\begin{lstlisting}
bool intersect (cpiece p1, cpiece p2)
{
  if (get_x(p1) == get_x(p2) && get_y(p1) == get_y(p2)) 
    return true;
  int x1=get_x(p1);
  int x2=get_x(p2);
  int y1=get_y(p1);
  int y2=get_y(p2);
  if ((x1 < x2+get_width(p2)) && (x1+get_width(p1) > x2))
    if ((y1 < y2+get_height(p2)) && (y1+get_height(p1) > y2))
      return true;
  return false;
}
\end{lstlisting}

\subsection{Module game}
\subsubsection{Structure d'un jeu}
Le plateau de jeu est définie par ses dimensions hauteur*largeur et l'ensemble de pièces qui le compose. Sa structure est donc composée des champs \textit{board} un tableau 2D représentant le plateau de jeu, les entiers \textit{width} et \textit{height} correspondants respectivement aux dimensions en largeur et en hauteur du plateau ainsi que du champs \textit{piece} qui va contenir toutes pièces qui seront présentes sur le jeu. \\
On dispose également du champs \textit{nb\_piece} pour connaître le nombre exact de pièces présentes en jeu et d'un dernier champs \textit{nb\_move} pour savoir combien de mouvement de pièces ont été réalisé depuis le début du jeu. Ce dernier champs est inclus dans la structure car il est propre à chaque jeu.\\
Dans la V1, comme notre jeu était fixé à un Rush Hour, nous avions décidé d'ajouter un champ dans notre structure qui était RedCar. En effet, on avait considére cette pièce comme capitale pour un jeu, alors nous l'avions mise à part. Néanmoins, lors de la réalisation de la V2, nous avons réalisé que cette pièce indépendante nous gênait pour créer un jeu complétement modulaire. C'est pourquoi, nous l'avons supprimé de notre structure.
\subsubsection{La fonction \textit{new\_game (int width, int height, int nb\_pieces, piece *pieces)}}
Pour créer un nouveau plateau de jeu, on initialise un tableau 2D par allocation dynamique de dimension \textit{width} et \textit{height}. On copie ensuite chaque pièces du tableau de pièces passé en paramètre dans le champs \textit{piece} après s'être assuré qu'elle ne soit pas en dehors du plateau. Une fois ces deux étapes effectuées, on place les pièces sur le plateau en attribuant à chaque case du plateau le numéro de la pièce qu'il l'occupe ou -1 si aucune pièce n'est présente.
\subsubsection{La fonction \textit{game new\_game\_hr (int nb\_piece, piece *piece)}}
Dans ce cas, on crée un jeu dont les conditions sont propres à Rush Hour.
Il s'agit d'un simple appel à la fonction \textit{new\_game} avec les dimensions d'un plateau de Rush Hour.
\subsubsection{La fonction \textit{void delete\_game (game g)}}
Elle nous permet de supprimer un jeu en libérant l'espace mémoire qu'il occupait. On supprime chaque pièce du champs \textit{piece} puis la plateau lui-même.
\subsubsection{La fonction \textit{play\_move(game g, int piece\_num, dir d, int distance)}}
Cette fonction tente de déplacer la pièce de numéro \textit{piece\_num} de \textit{distance} cases vers la direction \textit{d}. Si le mouvement est valide, c'est-à-dire qu'à l'issue de son déplacement elle est toujours dans la plateau, qu'elle ne vient pas occuper une case déja prise et que la direction de mouvement lui est permise, alors la pièce est déplacée et le nombre de mouvement effectué est incrémenté. Dans le cas où une des conditions ne serait pas valide, la fonction renvoie \textit{false} et la pièce n'est pas bougée.\\
On créé donc une autre pièce initialisé avec les valeurs que prendrait la pièce \textit{piece\_num} si elle était déplacée mais qui ne sera pas placée sur le plateau. Elle nous sert à vérifier que la position qu'occuperait la pièce \textit{piece\_num} après déplacement est valide ou non. Si elle est valide on modifie les valeurs de la pièce \textit{piece\_num} et on actualise la numérotation des cases du tableau.

\subsection{Module affichage}
\subsubsection*{Gestion des erreurs}
En parallèle du découpage effectué, la gestion des erreurs s'est voulue effectuée de façon fluide. Ainsi, un module \textbf{manage\_error.c} regroupe des informations caractéristiques des erreurs (usage de macros pour différents types d'erreurs, de façon la plus précise possible) et une encapsulation pour l'affichage de messages récapitulatifs des erreurs en question lors de leur apparition.
De plus, afin de minimiser l'exécution de sections potentiellement critiques du programme, lorsque cela a été possible les branchements conditionnels ont été effectués afin de prévenir l'exécution de code qui serait compromise par une erreur.
\subsubsection*{Point d'entrée}
Au lancement du programme, l'unité fonctionnelle intitulée \textbf{play.c} prend en charge l'initialisation du programme de la façon suivante :
\begin{itemize}
\item branchement avec le module \textbf{data.c} pour initialiser les champs de la structure qui conservera les données utiles au fil de l'exécution
\item appel du parseur des arguments passés en entrée au programme (\textit{parse\_argv})
\item le parseur effectue un branchement avec le module \textbf{opt.c} dédié à la détection des paramètres en entrée
\end{itemize}
\subsubsection*{Flux d'exécution}
En suite du point d'entrée, la gestion de la partie est transmise à l'unité fonctionnelle \textbf{move.c} qui se chargera de récupérer les instructions utilisateurs, d'effectuer les branchements avec le module \textbf{game.c} et de renvoyer à l'utilisateur la confirmation des modifications par le biais de l'affichage, ce passant par le module \textbf{term\_mode.c}, qui prend en charge l'affichage sur terminal en fournissant des outils de lecture/écriture sur celui-ci.

\subsection{Module play}
\subsubsection*{Point d'entrée}
Dans un premier temps, le main, notre point d'entrée dans le programme, voit son contenu varier suivant l'exécutable généré : des macros sont présentes pour que la compilation utilise le bon code pour générer l'exécutable du rush-hour ou de l'âne rouge.
Ensuite, le main effectue dans les deux cas les étapes suivantes :
\begin{itemize}
\item branchement avec le module \textbf{data.c} pour initialiser les champs de la structure associée qui permettra la transmission des informations utiles au cours de l'exécution 
\item appel de la fonction \textit{parse\_argv} pour la gestion des paramètres du programme 
\item branchement conditionnel sous la forme d'une boucle avec la fonction \textit{game\_loop} dédiée à la gestion du flux d'exécution tout au long de la partie 
\item en cas d'erreur critique, un branchement est effectué avec le module \textbf{manage\_error.c} 
\item avant la fin du programme, un second branchement est effectué avec le module \textbf{data.c} afin de libérer la mémoire allouée dynamiquement au cours de l'initialisation
\end{itemize}
\subsubsection*{La fonction \textit{parse\_argv(struct s\_data* data)}}
La fonction \textit{parse\_argv} est une encapsulation du parseur des arguments passés au programme lors de son lancement.
Elle va de ce fait analyser les arguments passés au programme afin d'en extraire les informations utiles au déroulement de la partie.
Ceci est effectué par le biais de branchements avec le module \textbf{opt.c}, dont l'objectif est de détecter et récupérer les paramètres necéssaires.
\subsubsection*{La fonction \textit{game\_loop(struct s\_data* data)}}
La fonction intitulée \textit{game\_loop} a pour vocation d'encapsuler le flux d'exécution lié au déroulement de la partie.\\
Le principe est le suivant :
\begin{itemize}
\item lors du premier appel se produit l'étape finale d'initialisation, à savoir un branchement au module \textbf{game.c} effectué par un appel de la fonction \textit{new\_game}
\item les appels à cette fonction au cours de la boucle d'exécution correspondent à un branchement avec le module d'affichage \textbf{term\_mode} (appel de \textit{printout\_game}) qui sera suivi d'un branchement avec le module \textbf{move.c} pour récupérer les instructions de déplacement de l'utilisateur sur le tour en cours.
\end{itemize}

\subsection{Module data}
\subsubsection*{La fonction \textit{init\_data(struct s\_data* data, int *argc, char** argv, bool (*game\_over)(cgame))}}
La fonction \textit{init\_data} permet d'initialiser les champs de la structure qui conservera la garde des informations necéssaires au programme pour son bon fonctionnement.
Cela correspond aux paramètres du programme, mais également à la fonction qui permettra au programme de savoir si une partie est terminée ou non.
\subsubsection*{La fonction \textit{delete\_data(struct s\_data* data)}}
Cette fonction est destinée à être appelée lorsque le programme est en fin de vie, ceci afin de libérer la mémoire allouée dynamiquement au cours de l'exécution.

\subsection{Module manage\_error}
\subsubsection{La fonction \textit{manage\_error(struct s\_data* data)}}
La fonction \textit{manage\_error} synthétise ce service et affichera donc un message d'erreur approprié pour informer l'utilisateur de la nature d'une erreur critique survenue.
De plus, ce module fournit des macros permettant à l'utilisateur de différencier les erreurs critiques entre elles (erreur de paramètre du programme, erreur d'allocation mémoire, ...).

\subsection{Module move}
\subsubsection*{La fonction \textit{manage\_move(struct s\_data* data)}}
La fonction \textit{manage\_move} encapsule la récupération de ces instructions en invoquant la fonction \textit{manage\_piece}.
\subsubsection*{La fonction \textit{manage\_piece(struct s\_data* data, char* buffer)}}
La fonction \textit{manage\_piece} récupère le numéro de la pièce que l'utilisateur souhaite déplacer.
Si un numéro de pièce invalide est entré ou si la lecture sur l'entrée standard de ce numéro a échoué, elle transmet cette information à l'utilisateur et se termine.
Lorsqu'un numéro valide est récupéré, la fonction "manage\_dir" est alors appélée.
\subsubsection*{La fonction \textit{manage\_dir(struct s\_data* data, const int nb\_pc, char* buffer)}}
La fonction \textit{manage\_dir} a pour vocation la récupération de la direction du mouvement de la pièce choisie par l'utilisateur.
En cas de mouvement invalide ou si la récupération de cette information échoue, cette fonction se termine.
Dans le cas d'un mouvement valide, la fonction effectue un branchement avec le module \textbf{game.c} en appelant la fonction \textit{play\_move} avec les paramètres récupérés précédement.

\subsection{Module opt}
\subsubsection*{Les fonctions \textit{is\_opt(const char* s)} et \textit{parse\_opt(struct s\_data* data)}}
Dans un premier temps, la fonction \textit{is\_opt} tente de détecter si le paramètre en cours d'analyse est une option du programme.
Ultérieurement à cette vérification, la fonction \textit{parse\_opt} va récupérer le paramètre et le traiter de façon appropriée (appel de la fonction \textit{parse\_input\_file} du module \textbf{parse\_file.c} par exemple).

\subsection{Module parse\_file}
\subsubsection*{La fonction \textit{parse\_input\_file(struct s\_data* data)}}
La fonction \textit{parse\_input\_file} encapsule le service rendu par le module \textbf{parse\_file.c}.
Elle va se contenter de lire le fichier passé en paramètre afin de récupérer les informations qu'il contient.

\subsection{Module term\_mode}
\subsubsection*{La fonction \textit{printout\_game(struct s\_data* data)}}
La fonction \textit{printout\_game} synthétise le service rendu par le module d'affichage en utilisant les données qui lui sont transmises au sein de notre structure globale de stockage des informations.

\subsection{Module xfunc}
Le module \textbf{xfunc.c} sépare des autres modules des fonctions dont le rôle est l'encapsulation d'appels systèmes dont le temps d'exécution est coûteux.
\subsubsection*{Fonction \textit{xmalloc(const unsigned int size, int* status)}}
Cette fonction fournit une encapsulation de l'appel système \textit{malloc} et réduit les branchements effectués avec celui-ci, en l'occurence en évitant l'appel lorsque la taille du bloc mémoire à allouer dynamiquement est nulle.
De plus, cette fonction a également l'avantage de fournir un second retour à l'utilisateur lorsqu'une erreur survient. En effet, un second paramètre est présent pour qu'à l'adresse qu'il renseigne il soit possible de spécifier qu'il y a eu une erreur.
\subsubsection*{Fonction \textit{xfree(void** ptr)}}
La fonction \textit{xfree} encapsule l'appel système \textit{free} qui n'est alors effectué que lorsque l'on passe l'adresse d'une adresse mémoire valide.
De plus, le passage de l'adresse où est stocké l'adresse du bloc mémoire à libérer permet de sécuriser ce traitement en modifiant l'adresse où est stockée cette information, qui contiendra alors en sortie de fonction l'adresse du pointeur nul.
L'objectif de ce double traitement est de réduire au maximum les branchements avec le noyau (invocation de l'appel système \textit{free}) ainsi que de supprimer le besoin de traitement supplémentaire en dehors de cette fonction (la variable qui contenait l'adresse de la mémoire à libérer contient donc l'adresse du pointeur nul après libération).


\subsection{Les structures de données}
\subsubsection{Liste simplement chaînée}
Pour la liste simplement chaînée, nous avons décidé de nous inspiré de notre UE d'algorithmique et structure de donnée. C'est pourquoi, nous avons implémenté les fonctions caractéristiques d'une liste simplement chainée avec des types génériques le plus possible. Ainsi, on a décidé que cette liste serait utilisable pour n'importe quel type de donnée.\\
La fonction qui semble importante a détaillé est celle qui crée une list: \textit{create\_list(void* data, list n\_list)}.
Cette fonction a une double fonctionnalité, c'est-à-dire qu'elle peut être utilisable aussi bien pour créer une list que pour ajouter un élément en tête d'une liste chaînée déjà créée. En effet, n\_list peut être simplement NULL s'il n'existe pas de list auparavant ou être une liste qui exitait avant.
\subsubsection{Les tables de hachage}
Pour la création du solveur, il a été décidé d'utiliser des tables de hachages. Les fonctions de bases d'une structure de données ont donc été implémentées, ainsi que des accesseurs des différents champs de la structure. De plus, des définitions de pointeurs de fonctions ont été créé. Ces fonctions et ces défintions, ainsi que la structure des tables de hachages, sont décrites ci-dessous.
\subsubsection*{Structure d'une table de hachage}
Chaque table de hachage est définie par:
\begin{itemize}
\item \textbf{tab} un tableau de listes contenant les éléments ajoutés
\item \textbf{length} la taille du tableau
\item \textbf{hf} la fonction de hachage permettant de placer des éléments dans le tableau
\end{itemize}
\textit{hashTab} est un pointeur sur une structure d'une table de hachage.
\subsubsection*{Le type \textit{chashTab}}
\textit{chashTab} est un pointeur constant sur une structure d'une table de hachage. Ainsi, aucune modification ne pourra etre apportée à la structure via ce pointeur.
\subsubsection*{Le type \textit{hashFunction}}
Une fonction de type \textit{hashFunction} est une fonction de hachage. Elle prend en paramètre un pointeur du type de l'élément à insérer dans la table de hachage et renvoie un pointeur sur l'indice où l'élément doit etre inséré.
\subsubsection*{Le type \textit{equalsFunction}}
Une fonction de type \textit{equalsFunction} est une fonction permettant de tester l'égalité de deux éléments à travers le pointeur. Elle gère elle-meme la conversion de type des pointeurs des éléments à comparer. Elle prend en paramètre deux pointeurs des éléments à comparer, et renvoie un booléen, \textit{true} si les éléments sont égaux, \textit{false} sinon.
\subsubsection*{La fonction \textit{create\_hash\_tab(int n, hashFunction f)}}
Cette fonction permet la création d'une table de hachage. Les paramètre \textit{n} et \textit{f} correspondent respectivement à la taille du tableau de listes qui va etre créé, et à la fonction de hachage qui sera utilisée pour mettre des éléments dans la table. Cette dernière est allouée dynamiquement. La fonction renvoie un un pointeur sur la structure nouvellement créée.
\subsubsection*{La fonction \textit{delete\_hash\_tab(hashTab h,void (*delete)(void *))}}
Cette fonction permet de libérer la mémoire qui a été allouée dynamiquement lors de la création d'une table de hachage, et donc de détruire cette dernière. Le paramètre \textit{h} passé en paramètre est un pointeur sur la table de hachage à détruire. Le paramètre \textit{delete} est un pointeur de fonction permettant, si les éléments ajoutés dans la table de hachage ont été créés dynamiquement, de détruire correctement ces éléments.
\subsubsection*{La fonction \textit{add\_hash\_tab(hashTab h,void* e,equalsFunction f)}}
Cette fonction permet d'ajouter l'élément donné par le pointeur \textit{e} dans la table de hachage \textit{h}, si l'élément n'a pas déjà été ajouté auparavant. Sinon, aucun ajout n'est effectué. \textit{f} est un pointeur sur la fonction permettant de tester l'égalité de deux éléments, et donc de vérifier si un élément a déjà été placé dans la table de hachage ou non.
\subsubsection*{La fonction \textit{delete\_hash\_tab(hashTab h,void* e,equalsFunction f,void (*delete)(void *))}}
Cette fonction permet de supprimer l'élément donné par le pointeur \textit{e} dans la table de hachage \textit{h}. \textit{f} est un pointeur sur la fonction permettant de vérifier si l'élément existe dans la table de hachage, et \textit{delete} est un pointeur sur la fonction permettant de libérer la mémoire occupée par l'élément s'il a été alloué dynamiquement.
\subsubsection*{La fonction \textit{get\_hash\_tab(chashTab h, void* e,equalsFunction f)}}
Cette fonction renvoie un pointeur sur l'élément pointé par \textit{e} s'il est contenu dans la table de hachage \textit{h}. \textit{f} est pointeur sur la fonction permettant de tester l'égalité entre l'élément recherché et les éléments contenus dans \textit{h}.
\subsubsection*{La fonction \textit{get\_length(chashTab h)}}
Cette fonction renvoie la taille du tableau contenant les éléments de la table de hachage.
\subsubsection*{La fonction \textit{get\_tab\_index(hashTab h, int index)}}
Cette fonction renvoie un pointeur sur le champ \textit{tab} à l'index indiqué en paramètre.

La fonction qui semble importante a détaillé est celle qui crée une list: \textit{create\_list(void* data, list n\_list)}

Cette fonction a une double fonctionnalité, c'est-à-dire qu'elle peut être utilisable aussi bien pour créer une list que pour ajouter un élément en tête d'une liste chaînée déjà créée. En effet, n\_list peut être simplement NULL s'il n'existe pas de list auparavant ou être une liste qui exitait avant. 

\subsection{Les tests}
Les fonction booléennes \textit{test\_equality\_...} testent l'égalité entre un élément attendu et un élément donné, renvoie \textit{true} s'il y a égalité, \textit{false} sinon. Dans ce dernier cas, un message d'erreur est envoyé, dont une partie est donnée en paramètre de ces fonctions. Cas particulier, la fonction \textit{test\_equality\_null} ne prend pas d'élément attendu en paramètre, car \textit{null} est l'élément attendu.\\
Toutes les fonctions de test sont booléennes, c'est-à-dire qu'elle renvoie \textit{true} si le test est réussi, \textit{false} sinon.
A noter que les accesseurs des champs des structures ne sont pas testés.
\subsubsection{Les tests de \textit{piece}}
\subsubsection*{La fonction \textit{test\_new\_piece}}
Cette fonction crée des structures \textit{piece} et vérifie que leurs champs sont correctement définis.
\subsubsection*{La fonction \textit{test\_intersect}}
Cette fonction teste deux cas d'intersection: l'intersection d'une pièce avec elle-meme, et un cas particulier d'intersection entre deux pièces.
\subsubsection*{La fonction \textit{test\_move}}
Cette fonction teste le changement de coordonnées d'une pièce après un déplacement, et vérifie donc si le déplacement a bien été effectuéé, ou pas, si le cas ne s'y pretait pas.
\subsubsection*{La fonction \textit{test\_copy}}
Cette fonction teste la copie d'une pièce en vérifiant l'égalité entre les champs de différentes pièces avec celles de leurs copies.
\subsubsection{Les tests de \textit{game}}
\subsubsection*{La fonction \textit{test\_new\_game}}
Cette fonction crée une structure \textit{game} et vérifie que ses champs sont correctement définis ou initialisés.
\subsubsection*{La fonction \textit{test\_copy}}
Cette fonction teste la copie d'un jeu en vérifiant l'égalité entre les champs de de la structure et celles de sa copie. Elle effectue notamment une vérification de la copie des pièces du jeu.
\subsubsection*{La fonction \textit{solve}}
Cette fonction tente de résoudre un jeu donné, et vérifie que les mouvements de pièces sont bien effectués, si et seulement si ils sont autorisés. Elle vérifie aussi que le champ \textit{nb\_moves} est bien mis à jour.
\subsubsection*{La fonction \textit{test\_game\_square\_piece}}
Cette fonction vérifie que le retour de la fonction \textit{game\_square\_piece} est correct dans plusieurs cas particuliers.
\subsubsection{Les tests de \textit{list}}
\subsubsection*{La fonction \textit{test\_create}}
Cette fonction teste si la création simpe d'une liste et la création en-tete d'une liste est correctement effectuée en vérifiant les champs de chaque liste.
\subsubsection*{La fonction \textit{test\_add\_after}}
Cette fonction teste l'ajout d'une liste après une première en vérifiant l'accessibilité de la liste créée par la liste déjà existante.
\subsubsection*{La fonction \textit{test\_erase\_first}}
Cette fonction teste la suppression d'une série de listes avec des suppressions en en-tete successives.
\subsubsection*{La fonction \textit{test\_erase\_after}}
Cette fonction teste la suppression d'une liste suivant une première en vérifiant le champ \textit{next} de la première, normallement mis à \textit{NULL}.
\subsubsection{Les tests de \textit{hashTab}}
\subsubsection*{La fonction \textit{test\_create}}
Cette fonction crée une structure \textit{hashTab} et vérifie que ses champs sont correctement définis ou initialisés.
\subsubsection*{La fonction \textit{test\_add}}
Cette fonction test l'ajout d'éléments dans une table de hachage en comparant le tableau de la table de hachage avec un tableau prédit.
\subsubsection*{La fonction \textit{test\_get}}
Cette fonction vérifie que le retour de la fonction \textit{test\_get} est correct dans plusieurs cas particuliers.
\subsubsection*{La fonction \textit{test\_delete}}
Cette fonction teste la supression d'éléments dans une table de hachage, en vérifiant que la fonction \textit{test\_get} renvoie \textit{NULL} pour différents éléments  après leur suppression.

\section{Répartition dans le temps et en espace}
\subsection*{Alexis}
La répartition du travail que j'ai effectué au cours du projet est la suivante :\\
- en espace :
\begin{itemize}
\item implémentation du squelette du programme : point d'entrée, initialisation et fin de vie du programme, branchements avec les modules \textbf{game.c} et \textbf{piece.c}
\item implémentation de l'interaction avec l'utilisateur : gestion des paramètres, interaction sur l'entrée pour récupérer les instructions utilisateur
\item implémentation de l'affichage.
\end{itemize}
- en temps :
\begin{itemize}
\item le travail requis pour l'implémentation des parties mentionnées ci-dessus représente un volume horaire compris entre 30 et 40 heures 
\item le volume de travail necéssaire pour parvenir à concevoir cette structure représente quand à lui un volume horaire situé entre 10 et 20 heures 
\item le volume de travail ayant conduit à l'élaboration des branchements entre les différents modules (en dehors des branchements déjà proposés entre les modules \textbf{game.c} et \textbf{piece.c}) se situe entre 10 et 20 heures.
\end{itemize}
\subsection*{Amélie}
Au niveau des tâches effectués, je vais faire un résumé de celles-ci :
\begin{itemize}
\item implémentation du module game de la V1:  15 heures TD compris
\item modification du module game V2 et résolution des problèmes de la V1 : 10 heures
\item listes simplement chaînée : 10 heures
\item solveur (surtout l'algorithme vu qu'il n'est pas fini à l'heure actuelle) : 30 heures
\end{itemize}
\subsection*{Anthony}
\begin{description}
\item [Module piece.C : ] Implémentation du module \textbf{piece.c}, toutes versions confondues (\textit{Approximativement 25 heures de travail})
\item [Tests unitaires des modules game.c et piece.c : ] Participation aux corrections des modules de tests et aux changements à apporter pour les besoins de la V2 (\textit{Approximativement 15 heures de travail})
\item [Module game.c : ] Correction des problèmes liés au module \textbf{game.c}, factorisation du code et finalisation de certaines fonctions (\textit{Approximativement 15 heures de travail})
\end{description}

\subsection*{Amélie}
Au niveau des tâches effectués, je vais faire un résumé de celles-ci :
\begin{itemize}
\item implémentation du module game de la V1:  15 heures TD compris
\item modification du module game V2 et résolution des problèmes de la V1 : 10 heures
\item listes simplement chaînée : 10 heures
\item solveur (surtout l'algorithme vu qu'il n'est pas fini à l'heure actuelle) : 30 heures
\end{itemize}


\chapter{Les difficultés rencontrées}
\setcounter{section}{0}
\section{Au niveau de la V1}
De problèmes au niveau du raisonnement sur l'algorithme de la fonction \textit{intersect (cpiece p1, cpiece p2)} du module \textbf{piece.c} ont demandé un certain temps avant d'être réglés, nécessitant de revoir à plusieurs reprise l'approche de cet algorithme. Ce n'était au final que de simples erreurs de raisonnement où certains cas dans lesquels deux pièces se chevauchaient n'étaient pas pris en compte, faussant le résultat.\\
Des problèmes au niveau du module \textbf{game.c} ont aussi été observés, notamment des fuites mémoires dues à des allocations dynamiques mal gérées.\\
L'absence d'une option permettant de savoir si une pièce se trouve sur une case donnée du tableau en connaissant uniquement les coordonnées de la case a rendu très difficile l'implémentation de l'affichage.
De plus, cela a également requis de conserver en dehors de la structure de données associée au module \textbf{game.c} les informations relatives au plateau, à savoir quelle pièce se trouve à telle case.\\
L'absence d'une configuration proposée pour la prise en charge d'un fichier de configuration a également ralenti le développement du programme.

\section{Au niveau de la V2}
L'absence d'un formatage proposé pour les fichiers de configuration a rendu laborieux l'implémentation des modifications.
De plus, le caractère statique de la bibliothèque associé au module \textbf{game.c} a requis d'en extraire la différentiation entre le rush-hour et l'âne rouge et de l'intégrer ailleurs.\\
Un autre problème rencontré est celui lié à le fonction \textit{copy\_game} du module \textbf{game.c}. En effet celle-ci ne passe pas le test qui lui est propre dans le module \textbf{test\_game.c}.

\section{Au niveau du solveur}
Suite au fait que l'on ne voyait pas comment entamer cette partie, nous avons perdu beaucoup de temps. De plus, comme on s'est réposé sur une personne et que celle-ci est tombée malade, le solveur a été fait beaucoup trop rapidement et donc ce n'est qu'une ébauche. De plus, l'algorithme formulé dans une partie précédente n'est valable que pour un Rush Hour que l'on peut qualifié de simple à résoudre. C'est pourquoi, la première approche aurait été plus optimisée pour un solveur.


\chapter{Pour aller plus loin}
\setcounter{section}{0}
\section{Analyse des problèmes rencontrés}
Des erreurs d'execution des fichiers de tests étaient pour la grande majorité dues à des erreurs d'implémentation des fichiers qu'il testaient ou dont ils étaient dépendants.\\
L'implémentation de la structure de données \textit{hashTab} n'est pas terminée, car même si la compilation ne provoque pas d'erreur, des erreurs flagrantes subsistent encore, comme par exemple, la non-supression d'élément.\\
Le problème lié à la fonction \textit{copy\_game} du module \textbf{game.c} et son test unitaire ne semble pas venir de la fonction en elle-même qui semble correcte. Il doit donc provenir d'une erreur passée inaperçue dans le test.\\
De plus, ce test et celui du module \textbf{piece.c} ont des fuites mémoires dues au fait que les variables allouées dynamiquement pour les besoins des tests n'ont pas étés libérées après usage. Une erreur malencontreuse pourtant facile à régler.\\
En ce qui concerne tous les problèmes qui nous ont causés des \textbf{segmentation fault}, il s'est souvent avéré que c'était un problème de raisonnement logique au niveau de sortie de tableau par exemple.\\
Il y a aussi eu des problèmes de raisonnement sur les imbrications de if ... else dans le module game qui ont été résolu par Anthony car étant donnée qu'il n'y avait qu'Amélie qui avait implémenté ce module elle n'arrivait pas à voir ces erreurs. La vision d'une autre personne a donc apporté une autre analyse du problème.\\
Un des problèmes majeur de notre groupe reste quand même la gestion du temps. Ce problème est probablement dû à un problème d'organisation au sein du groupe ainsi qu'à un manque de communication.

\section{Les améliorations a apporter au projet}
Il est raisonnable de penser que préférer la programmation Objet à la programmation Fonctionnelle aurait notablement réduit la quantité de travail nécessaire pour parvenir à un même résultat. Le paradigme Objet est très bien illustré par les modules \textbf{game.c} et \textbf{piece.c} dont l'encapsulation des données et les services rendus par les fonctions qu'ils contiennent correspondent au fonctionnement d'un Objet. De plus, le maintient et la portabilité du code produit auraient été facilités.\\
Dans cette optique d'optimisation, il aurait également été envisageable de choisir une implémentation Objet pour les modules \textbf{game.c} et \textbf{piece.c} tout en conservant une approche fonctionnelle pour le reste du programme (point d'entrée du programme, interactions entrée/sortie et branchements avec les modules \textbf{game.c} et \textbf{piece.c}).

\section{Ce que nous a apporté le projet}
Je pense que ce projet nous a apporté à tous un point de vue plus pratique sur les structures de donnée que l'on a vu cette année en Algorithmique. De plus, ce projet nous a permis de nous initié à la programmation au sein d'un groupe. Et nous a montré comment coopéré afin d'essayer d'obtenir des résultats.

Je pense que ce projet nous a apporté à tous un point de vue plus pratique sur les structures de donnée que l'on a vu cette année en Algorithmique. De plus, ce projet nous a permis de nous initié à la programmation au sein d'un groupe. Et nous a montré comment coopéré afin d'essayer d'obtenir des résultats.
\end{document}
